<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>有关于前端学习的个人博客</subtitle>
  <link href="/MyBlog/atom.xml" rel="self"/>
  
  <link href="https://qiuyuxiu.github.io/MyBlog/"/>
  <updated>2018-06-07T08:15:43.988Z</updated>
  <id>https://qiuyuxiu.github.io/MyBlog/</id>
  
  <author>
    <name>Daisy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markdown语法记录</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/Markdown%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/Markdown语法记录/</id>
    <published>2017-06-12T07:05:17.000Z</published>
    <updated>2018-06-07T08:15:43.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>总共六级标题，在#号后加一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></p><h2 id="换行和分段"><a href="#换行和分段" class="headerlink" title="换行和分段"></a>换行和分段</h2><ul><li>换行：只需在行末加两个空格键和一个回车键即可换行。快捷键：control + 回车键</li><li>分段：段落之间空一行即可。</li></ul><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">** 加粗 **</span><br><span class="line">* 斜体 *</span><br><span class="line">~~ 删除线 ~~</span><br><span class="line">` 底纹 `</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表直接在文字前加 -  或者 *  即可，有序列表则直接在文字前加数字 1. 2.。<br>符号要和文字之间加上一个字符的空格。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>只要在文本内容之前加  &gt; （大于号） 即可将文本变成引用文本。</p><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><ul><li>图片<br><code>![图片描述](链接的地址)</code></li><li>链接<br><code>[文本内容](链接的地址)</code></li></ul><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><p>三个 - 或 * 都可以画出一条水平分割线</p><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 两对(```)包裹</span><br><span class="line">- 代码前加四个空格键</span><br><span class="line">- 代码前加一个 tab 键</span><br></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注总是成对出现的，[^1]作为标记，可以点击跳至末尾注解。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释文字 --&gt;</span><br></pre></td></tr></table></figure></p><h2 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h2><p>在输入法的「全角」模式下，输入两个空格键即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;总共六级标题，在#号后加一个空格。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Markdown语法" scheme="https://qiuyuxiu.github.io/MyBlog/categories/Markdown%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Markdown语法" scheme="https://qiuyuxiu.github.io/MyBlog/tags/Markdown%E8%AF%AD%E6%B3%95/"/>
    
      <category term="前端技术" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo与github博客搭建</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/11/hexo%E4%B8%8Egithub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/11/hexo与github博客搭建/</id>
    <published>2017-06-11T11:10:00.000Z</published>
    <updated>2018-06-07T08:16:01.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步-安装Node-js"><a href="#第一步-安装Node-js" class="headerlink" title="第一步 安装Node.js"></a>第一步 安装Node.js</h2><p>在 Windows 环境下安装 Node.js ：到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 安装文件。<br>建议最好下载 nodist，这样方便之后的node版本管理。</p><h2 id="第二步-安装Git"><a href="#第二步-安装Git" class="headerlink" title="第二步 安装Git"></a>第二步 安装Git</h2><p>上官网下载git即可。</p><h2 id="第三步-hexo安装与使用"><a href="#第三步-hexo安装与使用" class="headerlink" title="第三步 hexo安装与使用"></a>第三步 hexo安装与使用</h2><ol><li><p>安装：<br>直接在桌面右键点击git bash here，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure></li><li><p>初始化配置：<br>创建文件夹(如 D:\self\myBlog)，直接进入myBlog文件夹下右键点击git bash here：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>安装hexo插件，(保证之后有些操作不出错, 以下代码可以一起复制粘贴到命令窗):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure></li><li><p>本地查看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li></ol><p>这样就可以在浏览器中访问localhost:4000</p><h2 id="第四步-将博客部署到Github-pages上"><a href="#第四步-将博客部署到Github-pages上" class="headerlink" title="第四步 将博客部署到Github pages上"></a>第四步 将博客部署到Github pages上</h2><ol><li>首先要有github账户。</li><li>创建新的repository，复制到你创建的repository的https链接。</li><li><p>在myBlog文件夹下打开_config.yml<br>在配置文件里修改：(记住：冒号后面一定要有空格！)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 你创建的repository的https链接</span><br><span class="line">  branch: 你的分支</span><br></pre></td></tr></table></figure></li><li><p>在myBlog文件夹下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>我是部署到master分支上，设置master分支为site分支，所以访问创建好的repository链接就能看到效果。<br>注明：如果你不能访问到css，js文件的话，说明路径不对，这时候可以修改_config.yml里面的root值，将root改成你的路径下。</p></li></ol><h2 id="第五步-添加主题美化博客"><a href="#第五步-添加主题美化博客" class="headerlink" title="第五步 添加主题美化博客"></a>第五步 添加主题美化博客</h2><ol><li>进入<a href="https://hexo.io/themes/，选择自己喜欢的主题，复制主题的github的地址。" target="_blank" rel="noopener">https://hexo.io/themes/，选择自己喜欢的主题，复制主题的github的地址。</a></li><li>在myBlog文件夹的themes目录下右键进入git命令框：<br>我选择的是hexo-theme-next 主题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址)</span><br></pre></td></tr></table></figure></li></ol><p>下载完之后。</p><ol start="3"><li>修改myBlog目录下的_config.yml文件里面的theme:hexo-theme-next</li><li><p>部署到github上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>打开自己的主页就能看到效果了。</p></li></ol><h2 id="第六步-配置分类与标签"><a href="#第六步-配置分类与标签" class="headerlink" title="第六步 配置分类与标签"></a>第六步 配置分类与标签</h2><ol><li><p>在myBlog文件夹下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot; // 创建分类</span><br><span class="line">hexo new page &quot;tags&quot; // 创建标签</span><br></pre></td></tr></table></figure></li><li><p>打开/source/categories路径下的index.md,将其修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: catagories</span><br><span class="line">date: 2017-06-11 19:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>打开/source/tags路径下的index.md,将其修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2017-06-11 19:40</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>打开scaffolds/post.md文件，在tags:上面加一行categories:</p></li><li>创建新页面：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;fisrtPage&quot;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到source/_post文件夹下有firstPage.md就能设置categories属性为你想要分类的值，标签设置如果多个标签，设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [tag1,tag2,...]</span><br></pre></td></tr></table></figure></p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><ol><li>设置中文<br>在_config.yml文件中找到language，设置为language: zh-Hans</li><li><p>主页显示分类与标签<br>找到所用主题文件夹（如themes的hexo-theme-next）里的_config.yml<br>找到menu配置处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure></li><li><p>首页不显示文章全文设置：<br>找到所用主题文件夹（如themes的hexo-theme-next）里的_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一步-安装Node-js&quot;&gt;&lt;a href=&quot;#第一步-安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;第一步 安装Node.js&quot;&gt;&lt;/a&gt;第一步 安装Node.js&lt;/h2&gt;&lt;p&gt;在 Windows 环境下安装 Node.js ：到
      
    
    </summary>
    
      <category term="博客创建" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/"/>
    
    
      <category term="hexo" scheme="https://qiuyuxiu.github.io/MyBlog/tags/hexo/"/>
    
      <category term="博客" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript一些规范</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/11/JavaScript%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/11/JavaScript一些规范/</id>
    <published>2017-06-11T08:19:43.000Z</published>
    <updated>2018-06-07T08:43:28.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隐式全局变量和显式全局变量的区别"><a href="#隐式全局变量和显式全局变量的区别" class="headerlink" title="隐式全局变量和显式全局变量的区别"></a>隐式全局变量和显式全局变量的区别</h2><p>隐式的全局变量和显式定义的全局变量之间有着细微的差别，差别在于通过delete来删除它们的时候表现不一致。</p><ul><li>通过var创建的全局变量（在任何函数体之外创建的变量）不能被删除。</li><li>没有用var创建的隐式全局变量（不考虑函数内的情况）可以被删除。<br>也就是说，隐式全局变量并不算是真正的变量，但他们是全局对象的属性成员。属性是可以通过delete运算符删除的，而变量不可以被删除。</li></ul><h2 id="枚举man对象的实例属性"><a href="#枚举man对象的实例属性" class="headerlink" title="枚举man对象的实例属性"></a>枚举man对象的实例属性</h2><p>另外一种的写法是通过Object.prototype 直接调用hasOwnProperty()方法，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i in man) &#123;</span><br><span class="line">if(Object.prototype.hasOwnProperty.call(man,i))&#123;</span><br><span class="line">console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i in man) &#123;</span><br><span class="line">    console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var i,</span><br><span class="line">    hasOwn = Object.prototype.hasOwnProperty;</span><br><span class="line">for (i in man) &#123;</span><br><span class="line">    if (hasOwn.call(man, i)) &#123; // filter</span><br><span class="line">        console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>new Function()的用法和eval()非常类似，应当特别注意。这种构造函数的方式很强大，但往往被误用。<br>如果你不得不使用eval()，你可以尝试用new Function()来代替。这有一个潜在的好处，在new Function()中运行的代码会在一个局部函数作用域内执行，因此源码中所有用var定义的变量不会自动变成全局变量。还有一种方法可以避免eval()中定义的变量转换为全局变量，即是将eval()包装在一个立即执行的匿名函数内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof un);// &quot;undefined&quot;</span><br><span class="line">console.log(typeof deux); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof trois); // &quot;undefined&quot;</span><br><span class="line">var jsstring = &quot;var un = 1; console.log(un);&quot;;</span><br><span class="line">eval(jsstring); // logs &quot;1&quot;</span><br><span class="line">jsstring = &quot;var deux = 2; console.log(deux);&quot;;</span><br><span class="line">new Function(jsstring)(); // logs &quot;2&quot;</span><br><span class="line">jsstring = &quot;var trois = 3; console.log(trois);&quot;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    eval(jsstring);</span><br><span class="line">&#125;()); // logs &quot;3&quot;</span><br><span class="line">console.log(typeof un); // &quot;number&quot;</span><br><span class="line">console.log(typeof deux); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof trois); // &quot;undefined&quot;</span><br></pre></td></tr></table></figure></p><p>eval()和Function构造函数还有一个区别，就是eval()可以修改作用域链，而Function更像是一个沙箱。不管在什么地方执行Function，它只能看到全局作用域。因此它不会太严重的污染局部变量。在下面的示例代码中，eval()可以访问且修改其作用域之外的变量，而Function不能（注意，使用Function和new Function是完全一样的）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var local = 1;</span><br><span class="line">    eval(&quot;local = 3; console.log(local)&quot;); // logs 3</span><br><span class="line">    console.log(local); // logs 3</span><br><span class="line">&#125;());</span><br><span class="line">(function () &#123;</span><br><span class="line">    var local = 1;</span><br><span class="line">    Function(&quot;console.log(typeof local);&quot;)(); // logs undefined</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>适合使用空格的地方包括：</p><ul><li>for循环中的分号之后，比如 <code>for (var i = 0; i &lt; 10; i += 1) {...}</code></li><li>for循环中初始化多个变量，比如 <code>for (var i = 0, max = 10; i &lt; max; i += 1) {...}</code></li><li>分隔数组项的逗号之后，<code>var a = [1, 2, 3];</code></li><li>对象属性后的逗号以及名值对之间的冒号之后，<code>var o = {a: 1, b: 2};</code></li><li>函数参数中，<code>myFunc(a, b, c)</code></li><li>函数声明的花括号之前，<code>function myFunc() {}</code></li><li>匿名函数表达式function之后，<code>var myFunc = function () {};</code></li><li>在运算符和操作数之间添加空格。也就是说在<code>+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=</code>符号前后都添加空格。</li></ul><h2 id="new"><a href="#new" class="headerlink" title="new()"></a>new()</h2><p>当你通过关键字new来调用这个构造函数时，函数体内将发生这些事情：</p><ul><li>创建一个空对象，将它的引用赋给this，继承函数的原型。</li><li>通过this将属性和方法添加至这个对象</li><li>最后返回this指向的新对象（如果没有手动返回其他的对象）</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol><li><p>对象：使用直接量创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var item = new Object();</span><br><span class="line">// good</span><br><span class="line">var item = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>不要使用保留字作为键名</p></li><li>使用同义词替换需要使用的保留字。</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>使用直接量创建数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var items = new Array();</span><br><span class="line">// good</span><br><span class="line">var items = [];</span><br></pre></td></tr></table></figure></li><li><p>向数组增加元素时使用 Array#push 来替代直接赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var someStack = [];</span><br><span class="line">// bad</span><br><span class="line">someStack[someStack.length] = &apos;abracadabra&apos;;</span><br><span class="line">// good</span><br><span class="line">someStack.push(&apos;abracadabra&apos;);</span><br></pre></td></tr></table></figure></li><li><p>当需要拷贝数组时，使用 Array#slice。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var len = items.length;</span><br><span class="line">var itemsCopy = [];</span><br><span class="line">var i;</span><br><span class="line">// bad</span><br><span class="line">for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">itemsCopy = items.slice();</span><br></pre></td></tr></table></figure></li><li><p>使用 Array#slice 将类数组对象转换成数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function trigger()&#123;</span><br><span class="line">  var args=Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li><p>使用单引号 <code>&#39;&#39;</code> 包裹字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var name = &quot;Bob Parr&quot;;</span><br><span class="line">// good</span><br><span class="line">var name = &apos;Bob Parr&apos;;</span><br><span class="line">// bad</span><br><span class="line">var fullName = &quot;Bob &quot; + this.lastName;</span><br><span class="line">// good</span><br><span class="line">var fullName = &apos;Bob &apos; + this.lastName;</span><br></pre></td></tr></table></figure></li><li><p>超过 100 个字符的字符串应该使用连接符写成多行。<br>注：若过度使用，通过连接符连接的长字符串可能会影响性能。</p></li><li>程序化生成的字符串使用 Array#join 连接而不是使用连接符。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var items;</span><br><span class="line">var messages;</span><br><span class="line">var length;</span><br><span class="line">var i;</span><br><span class="line">messages = [&#123;</span><br><span class="line">  state: &apos;success&apos;,</span><br><span class="line">  message: &apos;This one worked.&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  state: &apos;success&apos;,</span><br><span class="line">  message: &apos;This one worked as well.&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  state: &apos;error&apos;,</span><br><span class="line">  message: &apos;This one did not work.&apos;</span><br><span class="line">  &#125;];</span><br><span class="line">length = messages.length;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function inbox(messages) &#123;</span><br><span class="line">  items = &apos;&lt;ul&gt;&apos;;</span><br><span class="line">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">     items += &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return items + &apos;&lt;/ul&gt;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function inbox(messages) &#123;</span><br><span class="line">  items = [];</span><br><span class="line">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">  // use direct assignment in this case because we&apos;re micro-optimizing.</span><br><span class="line">   items[i] = &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &apos;&lt;ul&gt;&apos; + items.join(&apos;&apos;) + &apos;&lt;/ul&gt;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 匿名函数表达式</span><br><span class="line">var anonymous = function() &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line">// 命名函数表达式</span><br><span class="line">var named = function named() &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line">// 立即调用的函数表达式（IIFE）</span><br><span class="line">(function () &#123;</span><br><span class="line">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li><li><p>不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  function test() &#123;</span><br><span class="line">    console.log(&apos;Nope.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">var test;</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  test = function test() &#123;</span><br><span class="line">  console.log(&apos;Yup.&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function nope(name, options, arguments) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">function yup(name, options, args) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li>使用 . 来访问对象的属性。</li><li>当通过变量访问属性时使用中括号 []。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var luke = &#123;</span><br><span class="line">  jedi: true,</span><br><span class="line">  age: 28</span><br><span class="line">&#125;;</span><br><span class="line">function getProp(prop) &#123;</span><br><span class="line">  return luke[prop];</span><br><span class="line">&#125;</span><br><span class="line">var isJedi = getProp(&apos;jedi&apos;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li>总是使用 <code>var</code> 来声明变量。不这么做将导致产生全局变量。我们要避免污染全局命名空间。</li><li>使用 <code>var</code> 声明每一个变量。这样做的好处是增加新变量将变的更加容易，而且永远不用再担心调换错 <code>;</code>跟<code>,</code>。</li><li><p>最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">var items = getItems();</span><br><span class="line">var goSportsTeam = true;</span><br><span class="line">var dragonball;</span><br><span class="line">var length;</span><br><span class="line">var i;</span><br></pre></td></tr></table></figure></li><li><p>在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。</p></li></ol><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>见变量提升篇章</p><h2 id="注释规则"><a href="#注释规则" class="headerlink" title="注释规则"></a>注释规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* make() returns a new element 函数说明</span><br><span class="line">* based on the passed in tag name</span><br><span class="line">*</span><br><span class="line">* @param &#123;String&#125; tag 参数说明</span><br><span class="line">* @return &#123;Element&#125; element 返回值说明</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li><p>在语句开始时执行类型转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//  =&gt; this.reviewScore = 9;</span><br><span class="line">// bad</span><br><span class="line">var totalScore = this.reviewScore + &apos;&apos;;</span><br><span class="line">// good</span><br><span class="line">var totalScore = &apos;&apos; + this.reviewScore;</span><br><span class="line">// bad</span><br><span class="line">var totalScore = &apos;&apos; + this.reviewScore + &apos; total score&apos;;</span><br><span class="line">// good</span><br><span class="line">var totalScore = this.reviewScore + &apos; total score&apos;;</span><br></pre></td></tr></table></figure></li><li><p>使用 parseInt 转换数字时总是带上类型转换的基数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var val = parseInt(inputValue, 10);</span><br></pre></td></tr></table></figure></li></ol><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var age = 0;</span><br><span class="line">// bad</span><br><span class="line">var hasAge = new Boolean(age);</span><br><span class="line">// good</span><br><span class="line">var hasAge = Boolean(age);</span><br><span class="line">// good</span><br><span class="line">var hasAge = !!age;</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">$(this).trigger(&apos;listingUpdated&apos;, listing.id);</span><br><span class="line">...</span><br><span class="line">$(this).on(&apos;listingUpdated&apos;, function (e, listingId) &#123;</span><br><span class="line">// do something with listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>更好的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">$(this).trigger(‘listingUpdated’, &#123; listingId : listing.id &#125;);</span><br><span class="line">…</span><br><span class="line">$(this).on(‘listingUpdated’, function (e, data) &#123;</span><br><span class="line">// do something with data.listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="js-随手记"><a href="#js-随手记" class="headerlink" title="js 随手记"></a>js 随手记</h2><ol><li>引用类型的值是对象，保存在堆栈内存中，引用类型的变量是一个指针，保存在栈中，指向堆内存中的对象。</li><li>typeof null 返回的值是object</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;隐式全局变量和显式全局变量的区别&quot;&gt;&lt;a href=&quot;#隐式全局变量和显式全局变量的区别&quot; class=&quot;headerlink&quot; title=&quot;隐式全局变量和显式全局变量的区别&quot;&gt;&lt;/a&gt;隐式全局变量和显式全局变量的区别&lt;/h2&gt;&lt;p&gt;隐式的全局变量和显式定义的全
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="规范" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
</feed>
