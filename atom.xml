<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>有关于前端学习的个人博客</subtitle>
  <link href="/MyBlog/atom.xml" rel="self"/>
  
  <link href="https://qiuyuxiu.github.io/MyBlog/"/>
  <updated>2018-06-07T09:45:43.469Z</updated>
  <id>https://qiuyuxiu.github.io/MyBlog/</id>
  
  <author>
    <name>Daisy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS知识</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/CSS%E7%9F%A5%E8%AF%86/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/CSS知识/</id>
    <published>2017-06-12T09:05:08.000Z</published>
    <updated>2018-06-07T09:45:43.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。<br>有标准盒子模型，IE盒子模型。标准盒子模型的元素宽度是元素的内容content的width；IE盒子模型元素的宽度则包括content的width+padding+border。<br>CSS3中新增了一种盒模型计算方式：box-sizing熟悉。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下：</p><ul><li>content-box（默认）</li></ul><ol><li><p>布局所占宽度Width：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Width = width + padding-left + padding-right + border-left + border-right</span><br></pre></td></tr></table></figure></li><li><p>布局所占高度Height:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Height = height + padding-top + padding-bottom + border-top + border-bottom</span><br></pre></td></tr></table></figure></li></ol><ul><li>padding-box</li></ul><ol><li><p>布局所占宽度Width：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Width = width(包含padding-left + padding-right) + border-top + border-bottom</span><br></pre></td></tr></table></figure></li><li><p>布局所占高度Height:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</span><br></pre></td></tr></table></figure></li></ol><ul><li>border-box</li></ul><ol><li><p>布局所占宽度Width：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Width = width(包含padding-left + padding-right + border-left + border-right)</span><br></pre></td></tr></table></figure></li><li><p>布局所占高度Height:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</span><br></pre></td></tr></table></figure></li></ol><h2 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h2><ol><li>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</li><li>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</li><li>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</li></ol><h2 id="文字溢出"><a href="#文字溢出" class="headerlink" title="文字溢出"></a>文字溢出</h2><p>text-overflow(对溢出的文字使用省略号)</p><ol><li><p>单行文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure></li><li><p>多行文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">display:-webkit-box;</span><br><span class="line">-webkit-line-clamp:1;(行数)</span><br><span class="line">-webkit-box-orient:vertical;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CSS实现垂直水平居中"><a href="#CSS实现垂直水平居中" class="headerlink" title="CSS实现垂直水平居中"></a>CSS实现垂直水平居中</h2><ol><li>line-height: 高度;text-align：center;单行文字，图片</li><li>绝对定位居中：<br>(1)margin:0 auto;position: absolute;top:50%;left:0;right:0;bottom:0;margin-top:-(height/2);<br>(2)margin:auto;position: absolute;top:0;left:0;right:0;bottom:0;<br>(3)不知道高度时候：position: absolute;top:50%;left:50%;transform: translate(-50%,-50%);</li><li>模拟表格效果：IE6-IE7不支持<br>父元素：display:table;<br>子元素：display:table-cell;vertical-align:middle;</li><li><p>使用display:inline-block; 借用另一个元素的高度。（少用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;vertically-center&quot;&gt;</span><br><span class="line">    &lt;p&gt;aaabbb&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;extra&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">html,body&#123;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br><span class="line">#parent:&#123;height:500px;&#125;</span><br><span class="line">#vertical-center,#extra&#123;display:inline-block;vertical-align:middle;&#125;</span><br><span class="line">#extra&#123;height:100%;&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行内容居中：padding值设置。</p></li><li>使用flexbox：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display:flex;justify-content:center;align-items:center;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CSS-Hack"><a href="#CSS-Hack" class="headerlink" title="CSS Hack"></a>CSS Hack</h2><p>一般来说是针对不同的浏览器写不同的CSS,就是 CSS Hack。<br>IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：</p><ol><li><p>条件Hack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if IE]&gt;</span><br><span class="line">   &lt;style&gt;</span><br><span class="line">      .test&#123;color:red;&#125;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性Hack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  color:#090\9; /* For IE8+ */</span><br><span class="line">  *color:#f00;  /* For IE7 and earlier */</span><br><span class="line">  _color:#ff0;  /* For IE6 and earlier */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>选择符Hack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* html .test&#123;color:#090;&#125;       /* For IE6 and earlier */</span><br><span class="line">* + html .test&#123;color:#ff0;&#125;     /* For IE7 */</span><br></pre></td></tr></table></figure></li></ol><h2 id="px和em的区别"><a href="#px和em的区别" class="headerlink" title="px和em的区别"></a>px和em的区别</h2><p>px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em的值不是固定的，并且em会继承父级元素的字体大小。<br>浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em<br>rem是以根元素的字体大小为参照，即以html，body的font-size作为参照，所以rem是手机适配设置的方法之一。</p><h2 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h2><ul><li>background-size<br>对图片的铺满等设置：一般使用background-image,background-size:cover/contain/100%…<br>渐变问题：background:linear-gradient(top/bottom/角度…,fromColor,toColor);</li><li><p>opacity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opacity:0.5;</span><br><span class="line">filter:alpha(opacity=0.5)</span><br></pre></td></tr></table></figure></li><li><p>transform</p></li></ul><ol><li>transform:skew()/translate()/rotate()/scale()/matrix();</li><li>transition:(过渡) 样式 0.5s linear;</li><li>transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);<br>详情见 <a href="http://www.w3school.com.cn/cssref/pr_transition.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/cssref/pr_transition.asp</a></li></ol><ul><li>background<br>backface-visibility:hidden;不可见<br>background-clip:背景的边界不同 (content-box,border-box,padding-box);相当于截图</li><li>column<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.three-column&#123;</span><br><span class="line">padding: 1em;</span><br><span class="line">-moz-column-count: 3;</span><br><span class="line">-moz-column-gap: 1em;</span><br><span class="line">-webkit-column-count: 3;</span><br><span class="line">-webkit-column-gap: 1em;</span><br><span class="line">column-count: 3;</span><br><span class="line">column-gap: 1em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三个兼容浏览器的css前缀"><a href="#三个兼容浏览器的css前缀" class="headerlink" title="三个兼容浏览器的css前缀"></a>三个兼容浏览器的css前缀</h2><p>-webkit- : Safari 和 Chrome<br>-moz- : Firefox 4<br>-o- : Opera</p><h2 id="rem与em计算"><a href="#rem与em计算" class="headerlink" title="rem与em计算"></a>rem与em计算</h2><p>em=1/父元素的font-size * 需转换的像素值<br>默认 16px=1em<br>看根元素的px值，根元素的px值=1rem。</p><h2 id="弹性盒子模型flex"><a href="#弹性盒子模型flex" class="headerlink" title="弹性盒子模型flex"></a>弹性盒子模型flex</h2><p>display：flex;</p><ul><li>父元素（6属性）：flex-direction,flex-wrap,flex-flow,justify-content,align-items,align-content</li></ul><ol><li>flex-direction属性决定主轴的方向（即项目的排列方向）。<br><code>flex-direction: row | row-reverse | column | column-reverse;</code></li><li>flex-wrap属性<br>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><code>flex-wrap: nowrap | wrap | wrap-reverse;</code></li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br><code>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</code></li><li>justify-content属性定义了项目在主轴上的对齐方式。<br><code>justify-content: flex-start | flex-end | center | space-between | space-around;</code></li><li>align-items属性定义项目在交叉轴上如何对齐。<br><code>align-items: flex-start | flex-end | center | baseline | stretch;</code></li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</code></li></ol><ul><li>子元素（6属性）：order,flex-grow,flex-shrink,flex-basis,flex,align-self</li></ul><ol><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><code>order: &lt;integer&gt;;</code></li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><code>flex-grow: &lt;number&gt;; /* default 0 */</code></li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><code>flex-shrink: &lt;number&gt;; /* default 1 */</code></li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><code>flex-basis: &lt;length&gt; | auto; /* default auto */</code></li><li>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;</code><br>参考阮一峰博客：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li></ol><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>bootstrap 的响应式布局原理就是使用了媒体查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-width:600px)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><ol><li>CSS3边框<br>border-radius,box-shadow,border-image</li><li>CSS3背景<br>background-image,background-size,background-origin,background-repeat,background-position,background-clip(背景裁剪属性)<br>background-origin: border-box|content-box;<br>background-clip: border-box|padding-box|content-box;</li><li>CSS3渐变<br>background:linear-gradient(direction,color-stop1,color-stop2…)<br>repeat-linear-gradient:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#grad1 &#123;</span><br><span class="line">  background-image: repeating-linear-gradient(180deg,rgb(26,198,204),rgb(26,198,204) 7%, rgb(100,100,100) 10%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>background: radial-gradient(center,shareSize,start-color,…,end-color);<br>详情见：<a href="http://www.cnblogs.com/lhb25/archive/2013/02/24/css3-radial-gradient.html" target="_blank" rel="noopener">css3-radial-gradient</a></p><ol start="4"><li>CSS3文本效果<br>text-shadow,box-shadow,text-overflow,word-wrap,word-break<br>允许长文本换行：word-wrap: break-word;<br>单词拆分换行：word-break:keep-all;</li><li>2D转换<br>translate():通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。<br>rotate():通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。<br>scale():通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。<br>skew():通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。<br>matrix():<br>matrix()方法把所有 2D 转换方法组合在一起。<br>matrix()方法需要六个参数，包含数学函数，允许旋转、缩放、移动以及倾斜元素。</li><li>3D转换<br>translateY(),translate3D()….<br>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。<br>translate3d(x,y,z) 定义 3D 转化。<br>translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。<br>translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。<br>translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。<br>scale3d(x,y,z) 定义 3D 缩放转换。<br>scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。<br>scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。<br>scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。<br>rotate3d(x,y,z,angle) 定义 3D 旋转。<br>rotateX(angle) 定义沿 X 轴的 3D 旋转。<br>rotateY(angle) 定义沿 Y 轴的 3D 旋转。<br>rotateZ(angle) 定义沿 Z 轴的 3D 旋转。<br>perspective(n) 定义 3D 转换元素的透视视图。</li><li><p>3D过渡<br>transition-property<br>transition-duration<br>transition-timing-function<br>transition-delay<br>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure></li><li><p>CSS3动画<br>@keyframes规则：from to | 百分比时间帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  from&#123;background: red;&#125;</span><br><span class="line">  to&#123;background: blue;&#125;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;animation:myfirst 5s;&#125;</span><br></pre></td></tr></table></figure></li><li><p>CSS3图片<br>响应式图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">  max-width:100%;</span><br><span class="line">  height:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h2><ol><li>位置属性：(position,top,right,z-index,display,float)</li><li>水平：(width,height,padding,margin)</li><li>文字系列：(font,line-height,letter-spacing)</li><li>背景：(background,border)</li><li>其他：(animation,transition)</li></ol><h2 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h2><p>@font-face<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@font-face&#123;</span><br><span class="line">  font-family:&lt;yourFontName&gt;;</span><br><span class="line">  src: &lt;source&gt;;</span><br><span class="line">  [font-weight:&lt;weight&gt;];</span><br><span class="line">  [font-style:&lt;style&gt;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="浮动与清除浮动"><a href="#浮动与清除浮动" class="headerlink" title="浮动与清除浮动"></a>浮动与清除浮动</h2><p>浮动：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。<br>浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。显然标准流已经无法满足需求，这就要用到浮动。 浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。<br>造成高度塌陷：父类div不计算浮动元素的高度。<br>(1)父级div手动定义height<br>(2)父级div：overflow:hidden(不使用position)<br>(3)加空标签：clear:both<br>(4)父级使用伪类:after<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:after&#123;</span><br><span class="line">  display:block;</span><br><span class="line">  clear:both;</span><br><span class="line">  content:&quot;&quot;;</span><br><span class="line">  visibility:hidden;</span><br><span class="line">  height:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//IE兼容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><p>两栏布局，双飞翼布局，圣杯布局，响应式布局，瀑布流布局</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;盒子模型&quot;&gt;&lt;a href=&quot;#盒子模型&quot; class=&quot;headerlink&quot; title=&quot;盒子模型&quot;&gt;&lt;/a&gt;盒子模型&lt;/h2&gt;&lt;p&gt;在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的
      
    
    </summary>
    
      <category term="CSS" scheme="https://qiuyuxiu.github.io/MyBlog/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://qiuyuxiu.github.io/MyBlog/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Node.js创建服务器</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/Node-js%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/Node-js创建服务器/</id>
    <published>2017-06-12T08:51:27.000Z</published>
    <updated>2018-06-07T08:52:12.960Z</updated>
    
    <content type="html"><![CDATA[<p>使用Node.js创建web服务器来相应不同的页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var http=require(&apos;http&apos;);</span><br><span class="line">var fs=require(&apos;fs&apos;);</span><br><span class="line">var url=require(&apos;url&apos;);</span><br><span class="line">//开始web服务器</span><br><span class="line">exports.start=function()&#123;</span><br><span class="line">    var server=http.createServer();</span><br><span class="line">    server.on(&quot;connection&quot;,function()&#123;</span><br><span class="line">        console.log(&quot;一个客户连接！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    server.on(&quot;request&quot;,function(req,res)&#123;</span><br><span class="line">        //res是服务器向客户端的一个输出流</span><br><span class="line">        //req是客户端向服务器的一个输入流</span><br><span class="line">        res.write(&quot;hello world!&quot;);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">    server.listen(3000,function()&#123;</span><br><span class="line">        console.log(&quot;服务器开启成功！&quot;);</span><br><span class="line">    &#125;);//传入端口号</span><br><span class="line">&#125;</span><br><span class="line">exports.start2=function()&#123;</span><br><span class="line">    http.createServer(function(req,res)&#123;</span><br><span class="line">        var path=url.parse(req.url).path;</span><br><span class="line">        var filepath=&quot;&quot;;</span><br><span class="line">        if(path==&quot;/&quot;)&#123;</span><br><span class="line">            filepath=&quot;../index.html&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            filepath=&quot;../&quot;+path;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前请求文件是否存在</span><br><span class="line">        fs.exists(filepath,function(exists)&#123;</span><br><span class="line">            if(exists)&#123;</span><br><span class="line">                var rs=fs.createReadStream(filepath);</span><br><span class="line">                rs.pipe(res);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.statusCode=404;</span><br><span class="line">                var rs=fs.createReadStream(&quot;../404.html&quot;);</span><br><span class="line">                rs.pipe(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).listen(3000,function()&#123;</span><br><span class="line">        console.log(&quot;服务器开启成功！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Node.js创建web服务器来相应不同的页面。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="NodeJs" scheme="https://qiuyuxiu.github.io/MyBlog/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="https://qiuyuxiu.github.io/MyBlog/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript一些规范</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/JavaScript%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/JavaScript一些规范/</id>
    <published>2017-06-12T08:19:43.000Z</published>
    <updated>2018-06-07T08:44:56.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隐式全局变量和显式全局变量的区别"><a href="#隐式全局变量和显式全局变量的区别" class="headerlink" title="隐式全局变量和显式全局变量的区别"></a>隐式全局变量和显式全局变量的区别</h2><p>隐式的全局变量和显式定义的全局变量之间有着细微的差别，差别在于通过delete来删除它们的时候表现不一致。</p><ul><li>通过var创建的全局变量（在任何函数体之外创建的变量）不能被删除。</li><li>没有用var创建的隐式全局变量（不考虑函数内的情况）可以被删除。<br>也就是说，隐式全局变量并不算是真正的变量，但他们是全局对象的属性成员。属性是可以通过delete运算符删除的，而变量不可以被删除。</li></ul><h2 id="枚举man对象的实例属性"><a href="#枚举man对象的实例属性" class="headerlink" title="枚举man对象的实例属性"></a>枚举man对象的实例属性</h2><p>另外一种的写法是通过Object.prototype 直接调用hasOwnProperty()方法，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i in man) &#123;</span><br><span class="line">if(Object.prototype.hasOwnProperty.call(man,i))&#123;</span><br><span class="line">console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i in man) &#123;</span><br><span class="line">    console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var i,</span><br><span class="line">    hasOwn = Object.prototype.hasOwnProperty;</span><br><span class="line">for (i in man) &#123;</span><br><span class="line">    if (hasOwn.call(man, i)) &#123; // filter</span><br><span class="line">        console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>new Function()的用法和eval()非常类似，应当特别注意。这种构造函数的方式很强大，但往往被误用。<br>如果你不得不使用eval()，你可以尝试用new Function()来代替。这有一个潜在的好处，在new Function()中运行的代码会在一个局部函数作用域内执行，因此源码中所有用var定义的变量不会自动变成全局变量。还有一种方法可以避免eval()中定义的变量转换为全局变量，即是将eval()包装在一个立即执行的匿名函数内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof un);// &quot;undefined&quot;</span><br><span class="line">console.log(typeof deux); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof trois); // &quot;undefined&quot;</span><br><span class="line">var jsstring = &quot;var un = 1; console.log(un);&quot;;</span><br><span class="line">eval(jsstring); // logs &quot;1&quot;</span><br><span class="line">jsstring = &quot;var deux = 2; console.log(deux);&quot;;</span><br><span class="line">new Function(jsstring)(); // logs &quot;2&quot;</span><br><span class="line">jsstring = &quot;var trois = 3; console.log(trois);&quot;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    eval(jsstring);</span><br><span class="line">&#125;()); // logs &quot;3&quot;</span><br><span class="line">console.log(typeof un); // &quot;number&quot;</span><br><span class="line">console.log(typeof deux); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof trois); // &quot;undefined&quot;</span><br></pre></td></tr></table></figure></p><p>eval()和Function构造函数还有一个区别，就是eval()可以修改作用域链，而Function更像是一个沙箱。不管在什么地方执行Function，它只能看到全局作用域。因此它不会太严重的污染局部变量。在下面的示例代码中，eval()可以访问且修改其作用域之外的变量，而Function不能（注意，使用Function和new Function是完全一样的）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var local = 1;</span><br><span class="line">    eval(&quot;local = 3; console.log(local)&quot;); // logs 3</span><br><span class="line">    console.log(local); // logs 3</span><br><span class="line">&#125;());</span><br><span class="line">(function () &#123;</span><br><span class="line">    var local = 1;</span><br><span class="line">    Function(&quot;console.log(typeof local);&quot;)(); // logs undefined</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>适合使用空格的地方包括：</p><ul><li>for循环中的分号之后，比如 <code>for (var i = 0; i &lt; 10; i += 1) {...}</code></li><li>for循环中初始化多个变量，比如 <code>for (var i = 0, max = 10; i &lt; max; i += 1) {...}</code></li><li>分隔数组项的逗号之后，<code>var a = [1, 2, 3];</code></li><li>对象属性后的逗号以及名值对之间的冒号之后，<code>var o = {a: 1, b: 2};</code></li><li>函数参数中，<code>myFunc(a, b, c)</code></li><li>函数声明的花括号之前，<code>function myFunc() {}</code></li><li>匿名函数表达式function之后，<code>var myFunc = function () {};</code></li><li>在运算符和操作数之间添加空格。也就是说在<code>+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=</code>符号前后都添加空格。</li></ul><h2 id="new"><a href="#new" class="headerlink" title="new()"></a>new()</h2><p>当你通过关键字new来调用这个构造函数时，函数体内将发生这些事情：</p><ul><li>创建一个空对象，将它的引用赋给this，继承函数的原型。</li><li>通过this将属性和方法添加至这个对象</li><li>最后返回this指向的新对象（如果没有手动返回其他的对象）</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol><li><p>对象：使用直接量创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var item = new Object();</span><br><span class="line">// good</span><br><span class="line">var item = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>不要使用保留字作为键名</p></li><li>使用同义词替换需要使用的保留字。</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>使用直接量创建数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var items = new Array();</span><br><span class="line">// good</span><br><span class="line">var items = [];</span><br></pre></td></tr></table></figure></li><li><p>向数组增加元素时使用 Array#push 来替代直接赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var someStack = [];</span><br><span class="line">// bad</span><br><span class="line">someStack[someStack.length] = &apos;abracadabra&apos;;</span><br><span class="line">// good</span><br><span class="line">someStack.push(&apos;abracadabra&apos;);</span><br></pre></td></tr></table></figure></li><li><p>当需要拷贝数组时，使用 Array#slice。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var len = items.length;</span><br><span class="line">var itemsCopy = [];</span><br><span class="line">var i;</span><br><span class="line">// bad</span><br><span class="line">for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">itemsCopy = items.slice();</span><br></pre></td></tr></table></figure></li><li><p>使用 Array#slice 将类数组对象转换成数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function trigger()&#123;</span><br><span class="line">  var args=Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li><p>使用单引号 <code>&#39;&#39;</code> 包裹字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var name = &quot;Bob Parr&quot;;</span><br><span class="line">// good</span><br><span class="line">var name = &apos;Bob Parr&apos;;</span><br><span class="line">// bad</span><br><span class="line">var fullName = &quot;Bob &quot; + this.lastName;</span><br><span class="line">// good</span><br><span class="line">var fullName = &apos;Bob &apos; + this.lastName;</span><br></pre></td></tr></table></figure></li><li><p>超过 100 个字符的字符串应该使用连接符写成多行。<br>注：若过度使用，通过连接符连接的长字符串可能会影响性能。</p></li><li>程序化生成的字符串使用 Array#join 连接而不是使用连接符。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var items;</span><br><span class="line">var messages;</span><br><span class="line">var length;</span><br><span class="line">var i;</span><br><span class="line">messages = [&#123;</span><br><span class="line">  state: &apos;success&apos;,</span><br><span class="line">  message: &apos;This one worked.&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  state: &apos;success&apos;,</span><br><span class="line">  message: &apos;This one worked as well.&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  state: &apos;error&apos;,</span><br><span class="line">  message: &apos;This one did not work.&apos;</span><br><span class="line">  &#125;];</span><br><span class="line">length = messages.length;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function inbox(messages) &#123;</span><br><span class="line">  items = &apos;&lt;ul&gt;&apos;;</span><br><span class="line">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">     items += &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return items + &apos;&lt;/ul&gt;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function inbox(messages) &#123;</span><br><span class="line">  items = [];</span><br><span class="line">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">  // use direct assignment in this case because we&apos;re micro-optimizing.</span><br><span class="line">   items[i] = &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &apos;&lt;ul&gt;&apos; + items.join(&apos;&apos;) + &apos;&lt;/ul&gt;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 匿名函数表达式</span><br><span class="line">var anonymous = function() &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line">// 命名函数表达式</span><br><span class="line">var named = function named() &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line">// 立即调用的函数表达式（IIFE）</span><br><span class="line">(function () &#123;</span><br><span class="line">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li><li><p>不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  function test() &#123;</span><br><span class="line">    console.log(&apos;Nope.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">var test;</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  test = function test() &#123;</span><br><span class="line">  console.log(&apos;Yup.&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function nope(name, options, arguments) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">function yup(name, options, args) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li>使用 . 来访问对象的属性。</li><li>当通过变量访问属性时使用中括号 []。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var luke = &#123;</span><br><span class="line">  jedi: true,</span><br><span class="line">  age: 28</span><br><span class="line">&#125;;</span><br><span class="line">function getProp(prop) &#123;</span><br><span class="line">  return luke[prop];</span><br><span class="line">&#125;</span><br><span class="line">var isJedi = getProp(&apos;jedi&apos;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li>总是使用 <code>var</code> 来声明变量。不这么做将导致产生全局变量。我们要避免污染全局命名空间。</li><li>使用 <code>var</code> 声明每一个变量。这样做的好处是增加新变量将变的更加容易，而且永远不用再担心调换错 <code>;</code>跟<code>,</code>。</li><li><p>最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">var items = getItems();</span><br><span class="line">var goSportsTeam = true;</span><br><span class="line">var dragonball;</span><br><span class="line">var length;</span><br><span class="line">var i;</span><br></pre></td></tr></table></figure></li><li><p>在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。</p></li></ol><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>见变量提升篇章</p><h2 id="注释规则"><a href="#注释规则" class="headerlink" title="注释规则"></a>注释规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* make() returns a new element 函数说明</span><br><span class="line">* based on the passed in tag name</span><br><span class="line">*</span><br><span class="line">* @param &#123;String&#125; tag 参数说明</span><br><span class="line">* @return &#123;Element&#125; element 返回值说明</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li><p>在语句开始时执行类型转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//  =&gt; this.reviewScore = 9;</span><br><span class="line">// bad</span><br><span class="line">var totalScore = this.reviewScore + &apos;&apos;;</span><br><span class="line">// good</span><br><span class="line">var totalScore = &apos;&apos; + this.reviewScore;</span><br><span class="line">// bad</span><br><span class="line">var totalScore = &apos;&apos; + this.reviewScore + &apos; total score&apos;;</span><br><span class="line">// good</span><br><span class="line">var totalScore = this.reviewScore + &apos; total score&apos;;</span><br></pre></td></tr></table></figure></li><li><p>使用 parseInt 转换数字时总是带上类型转换的基数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var val = parseInt(inputValue, 10);</span><br></pre></td></tr></table></figure></li></ol><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var age = 0;</span><br><span class="line">// bad</span><br><span class="line">var hasAge = new Boolean(age);</span><br><span class="line">// good</span><br><span class="line">var hasAge = Boolean(age);</span><br><span class="line">// good</span><br><span class="line">var hasAge = !!age;</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">$(this).trigger(&apos;listingUpdated&apos;, listing.id);</span><br><span class="line">...</span><br><span class="line">$(this).on(&apos;listingUpdated&apos;, function (e, listingId) &#123;</span><br><span class="line">// do something with listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>更好的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">$(this).trigger(‘listingUpdated’, &#123; listingId : listing.id &#125;);</span><br><span class="line">…</span><br><span class="line">$(this).on(‘listingUpdated’, function (e, data) &#123;</span><br><span class="line">// do something with data.listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="js-随手记"><a href="#js-随手记" class="headerlink" title="js 随手记"></a>js 随手记</h2><ol><li>引用类型的值是对象，保存在堆栈内存中，引用类型的变量是一个指针，保存在栈中，指向堆内存中的对象。</li><li>typeof null 返回的值是object</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;隐式全局变量和显式全局变量的区别&quot;&gt;&lt;a href=&quot;#隐式全局变量和显式全局变量的区别&quot; class=&quot;headerlink&quot; title=&quot;隐式全局变量和显式全局变量的区别&quot;&gt;&lt;/a&gt;隐式全局变量和显式全局变量的区别&lt;/h2&gt;&lt;p&gt;隐式的全局变量和显式定义的全
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="规范" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法记录</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/Markdown%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/Markdown语法记录/</id>
    <published>2017-06-12T07:05:17.000Z</published>
    <updated>2018-06-07T08:15:43.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>总共六级标题，在#号后加一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></p><h2 id="换行和分段"><a href="#换行和分段" class="headerlink" title="换行和分段"></a>换行和分段</h2><ul><li>换行：只需在行末加两个空格键和一个回车键即可换行。快捷键：control + 回车键</li><li>分段：段落之间空一行即可。</li></ul><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">** 加粗 **</span><br><span class="line">* 斜体 *</span><br><span class="line">~~ 删除线 ~~</span><br><span class="line">` 底纹 `</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表直接在文字前加 -  或者 *  即可，有序列表则直接在文字前加数字 1. 2.。<br>符号要和文字之间加上一个字符的空格。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>只要在文本内容之前加  &gt; （大于号） 即可将文本变成引用文本。</p><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><ul><li>图片<br><code>![图片描述](链接的地址)</code></li><li>链接<br><code>[文本内容](链接的地址)</code></li></ul><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><p>三个 - 或 * 都可以画出一条水平分割线</p><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 两对(```)包裹</span><br><span class="line">- 代码前加四个空格键</span><br><span class="line">- 代码前加一个 tab 键</span><br></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注总是成对出现的，[^1]作为标记，可以点击跳至末尾注解。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释文字 --&gt;</span><br></pre></td></tr></table></figure></p><h2 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h2><p>在输入法的「全角」模式下，输入两个空格键即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;总共六级标题，在#号后加一个空格。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Markdown语法" scheme="https://qiuyuxiu.github.io/MyBlog/categories/Markdown%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Markdown语法" scheme="https://qiuyuxiu.github.io/MyBlog/tags/Markdown%E8%AF%AD%E6%B3%95/"/>
    
      <category term="前端技术" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo与github博客搭建</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/11/hexo%E4%B8%8Egithub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/11/hexo与github博客搭建/</id>
    <published>2017-06-11T11:10:00.000Z</published>
    <updated>2018-06-07T08:16:01.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步-安装Node-js"><a href="#第一步-安装Node-js" class="headerlink" title="第一步 安装Node.js"></a>第一步 安装Node.js</h2><p>在 Windows 环境下安装 Node.js ：到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 安装文件。<br>建议最好下载 nodist，这样方便之后的node版本管理。</p><h2 id="第二步-安装Git"><a href="#第二步-安装Git" class="headerlink" title="第二步 安装Git"></a>第二步 安装Git</h2><p>上官网下载git即可。</p><h2 id="第三步-hexo安装与使用"><a href="#第三步-hexo安装与使用" class="headerlink" title="第三步 hexo安装与使用"></a>第三步 hexo安装与使用</h2><ol><li><p>安装：<br>直接在桌面右键点击git bash here，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure></li><li><p>初始化配置：<br>创建文件夹(如 D:\self\myBlog)，直接进入myBlog文件夹下右键点击git bash here：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>安装hexo插件，(保证之后有些操作不出错, 以下代码可以一起复制粘贴到命令窗):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure></li><li><p>本地查看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li></ol><p>这样就可以在浏览器中访问localhost:4000</p><h2 id="第四步-将博客部署到Github-pages上"><a href="#第四步-将博客部署到Github-pages上" class="headerlink" title="第四步 将博客部署到Github pages上"></a>第四步 将博客部署到Github pages上</h2><ol><li>首先要有github账户。</li><li>创建新的repository，复制到你创建的repository的https链接。</li><li><p>在myBlog文件夹下打开_config.yml<br>在配置文件里修改：(记住：冒号后面一定要有空格！)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 你创建的repository的https链接</span><br><span class="line">  branch: 你的分支</span><br></pre></td></tr></table></figure></li><li><p>在myBlog文件夹下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>我是部署到master分支上，设置master分支为site分支，所以访问创建好的repository链接就能看到效果。<br>注明：如果你不能访问到css，js文件的话，说明路径不对，这时候可以修改_config.yml里面的root值，将root改成你的路径下。</p></li></ol><h2 id="第五步-添加主题美化博客"><a href="#第五步-添加主题美化博客" class="headerlink" title="第五步 添加主题美化博客"></a>第五步 添加主题美化博客</h2><ol><li>进入<a href="https://hexo.io/themes/，选择自己喜欢的主题，复制主题的github的地址。" target="_blank" rel="noopener">https://hexo.io/themes/，选择自己喜欢的主题，复制主题的github的地址。</a></li><li>在myBlog文件夹的themes目录下右键进入git命令框：<br>我选择的是hexo-theme-next 主题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址)</span><br></pre></td></tr></table></figure></li></ol><p>下载完之后。</p><ol start="3"><li>修改myBlog目录下的_config.yml文件里面的theme:hexo-theme-next</li><li><p>部署到github上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>打开自己的主页就能看到效果了。</p></li></ol><h2 id="第六步-配置分类与标签"><a href="#第六步-配置分类与标签" class="headerlink" title="第六步 配置分类与标签"></a>第六步 配置分类与标签</h2><ol><li><p>在myBlog文件夹下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot; // 创建分类</span><br><span class="line">hexo new page &quot;tags&quot; // 创建标签</span><br></pre></td></tr></table></figure></li><li><p>打开/source/categories路径下的index.md,将其修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: catagories</span><br><span class="line">date: 2017-06-11 19:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>打开/source/tags路径下的index.md,将其修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2017-06-11 19:40</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>打开scaffolds/post.md文件，在tags:上面加一行categories:</p></li><li>创建新页面：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;fisrtPage&quot;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到source/_post文件夹下有firstPage.md就能设置categories属性为你想要分类的值，标签设置如果多个标签，设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [tag1,tag2,...]</span><br></pre></td></tr></table></figure></p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><ol><li>设置中文<br>在_config.yml文件中找到language，设置为language: zh-Hans</li><li><p>主页显示分类与标签<br>找到所用主题文件夹（如themes的hexo-theme-next）里的_config.yml<br>找到menu配置处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure></li><li><p>首页不显示文章全文设置：<br>找到所用主题文件夹（如themes的hexo-theme-next）里的_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一步-安装Node-js&quot;&gt;&lt;a href=&quot;#第一步-安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;第一步 安装Node.js&quot;&gt;&lt;/a&gt;第一步 安装Node.js&lt;/h2&gt;&lt;p&gt;在 Windows 环境下安装 Node.js ：到
      
    
    </summary>
    
      <category term="博客创建" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/"/>
    
    
      <category term="hexo" scheme="https://qiuyuxiu.github.io/MyBlog/tags/hexo/"/>
    
      <category term="博客" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
