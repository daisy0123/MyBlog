<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>有关于前端学习的个人博客</subtitle>
  <link href="/MyBlog/atom.xml" rel="self"/>
  
  <link href="https://qiuyuxiu.github.io/MyBlog/"/>
  <updated>2018-06-08T11:22:49.887Z</updated>
  <id>https://qiuyuxiu.github.io/MyBlog/</id>
  
  <author>
    <name>Daisy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript DOM</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/JavaScript-DOM/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/JavaScript-DOM/</id>
    <published>2018-06-08T11:22:49.000Z</published>
    <updated>2018-06-08T11:22:49.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript DOM扩展</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/JavaScript-DOM%E6%89%A9%E5%B1%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/JavaScript-DOM扩展/</id>
    <published>2018-06-08T11:22:44.000Z</published>
    <updated>2018-06-08T11:22:44.082Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript DOM2和DOM3</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/JavaScript-DOM2%E5%92%8CDOM3/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/JavaScript-DOM2和DOM3/</id>
    <published>2018-06-08T11:22:31.000Z</published>
    <updated>2018-06-08T11:22:31.344Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript事件</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/JavaScript%E4%BA%8B%E4%BB%B6/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/JavaScript事件/</id>
    <published>2018-06-08T11:22:05.000Z</published>
    <updated>2018-06-08T11:22:05.633Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP状态码与方法</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/HTTP状态码与方法/</id>
    <published>2018-06-08T11:21:20.000Z</published>
    <updated>2018-06-08T11:21:20.422Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP报文</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/HTTP%E6%8A%A5%E6%96%87/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/HTTP报文/</id>
    <published>2018-06-08T11:19:33.000Z</published>
    <updated>2018-06-08T11:19:33.604Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>304状态码理解</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/304%E7%8A%B6%E6%80%81%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/304状态码理解/</id>
    <published>2018-06-08T11:19:16.000Z</published>
    <updated>2018-06-08T11:19:16.240Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用nvm管理node版本</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E4%BD%BF%E7%94%A8nvm%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/使用nvm管理node版本/</id>
    <published>2018-06-08T11:18:13.000Z</published>
    <updated>2018-06-08T11:18:13.485Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jQuery多种插件使用说明</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/jQuery%E5%A4%9A%E7%A7%8D%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/jQuery多种插件使用说明/</id>
    <published>2018-06-08T11:17:55.000Z</published>
    <updated>2018-06-08T11:17:55.538Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>html知识点</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/html%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/html知识点/</id>
    <published>2018-06-08T11:17:33.000Z</published>
    <updated>2018-06-08T11:17:33.349Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存泄漏问题</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/内存泄漏问题/</id>
    <published>2018-06-08T08:53:07.000Z</published>
    <updated>2018-06-08T08:53:07.783Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手写promise</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E6%89%8B%E5%86%99promise/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/手写promise/</id>
    <published>2018-06-08T08:52:57.000Z</published>
    <updated>2018-06-08T08:52:58.018Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSONP</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/JSONP/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/JSONP/</id>
    <published>2018-06-08T08:52:46.000Z</published>
    <updated>2018-06-08T08:52:46.608Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http三个版本</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/http%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/http三个版本/</id>
    <published>2018-06-08T08:52:34.000Z</published>
    <updated>2018-06-08T08:52:34.088Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>长连接&amp;短连接&amp;长轮询&amp;短轮询</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5-%E9%95%BF%E8%BD%AE%E8%AF%A2-%E7%9F%AD%E8%BD%AE%E8%AF%A2/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/长连接-短连接-长轮询-短轮询/</id>
    <published>2018-06-08T08:52:19.000Z</published>
    <updated>2018-06-08T08:52:19.904Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript BOM</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/20/JavaScript-BOM/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/20/JavaScript-BOM/</id>
    <published>2017-06-20T11:22:55.000Z</published>
    <updated>2018-06-09T07:25:06.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>在全局作用域中声明的变量、函数都会变成window对象的属性和方法。全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var age=29;</span><br><span class="line">function sayAge()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">alert(window.age);//29</span><br><span class="line">sayAge();//29</span><br><span class="line">window.sayAge();//29</span><br></pre></td></tr></table></figure></p><p>在全局作用域中定义了age变量和sayAge()方法，他们都属于window对象的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var age=29;</span><br><span class="line">window.color=&quot;red&quot;;</span><br><span class="line">delete window.age;</span><br><span class="line">delete window.color;</span><br><span class="line">alert(window.age);//29</span><br><span class="line">alert(window.color);//undefined</span><br></pre></td></tr></table></figure></p><p>可见全局变量age不可以删除，在window对象上的属性color可以被删除掉。</p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><p>screenLeft 和 screenTop 属性：用来表示窗口相对于屏幕左边和上边的位置。<br>screenX 和 screenY 属性：提供相同的窗口位置信息。<br>但两者支持的浏览器不同。下面的代码可以跨浏览器取得窗口左边和上边的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var leftPos=(typeof window.screenLeft==&apos;number&apos;)?window.screenLeft:window.screenX;</span><br><span class="line">var topPos=(typeof window.screenTop==&apos;number&apos;)?window.screenTop:window.screenY;</span><br><span class="line">document.write(leftPos+&quot;  &quot;+topPos);</span><br></pre></td></tr></table></figure></p><p>全屏的情况下值为0 0。<br>moveTo()和moveBy() 是将窗口移动到一个新位置。<br>moveTo() 接受的是新位置的x和y坐标值，而moveBy() 接受的是在水平和垂直方向上移动的像素数。 但是现在很多浏览器已经禁用了。</p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>outerWidth和outerHeight返回浏览器窗口本身的尺寸；<br>innerWidth和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。<br>不同的浏览器支持的窗口大小的表示方式不同,因此也需要考虑浏览器兼容性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var pageWidth=window.innerWidth;</span><br><span class="line">var pageHeight=window.innerHeight;</span><br><span class="line">if(typeof pageWidth!=&apos;number&apos;)&#123;</span><br><span class="line">    if(document.compatMode==&quot;CSS1Compat&quot;)&#123;</span><br><span class="line">        pageWidth=document.documentElement.clientWidth;</span><br><span class="line">        pageHeight=document.documentElement.clientHeight;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        pageWidth=document.body.clientWidth;</span><br><span class="line">        pageHeight=document.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">document.write(pageWidth+&quot;   &quot;+pageHeight);</span><br></pre></td></tr></table></figure></p><p>resizeTo() 和 resizeBy() 方法可以调整浏览器窗口的大小。<br>resizeTo()接受的是窗口的新宽度和新高度，而resizeBy() 接受的是新窗口与原窗口的宽度和高度之差。不过现在有些浏览器也是禁用了的。</p><h4 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h4><p><code>window.open()</code> 方法可以接收四个参数：要加载的url，窗口目标，一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。第二个参数可以是：_self,_blank,_parent,_top。第三个参数可以是窗口的一些特性，例如width，height等等。<br><code>window.open(&quot; &quot;,&#39;myWin&#39;,&#39;width=200,height=200,top=100,left=50&#39;);</code><br><code>window.close()</code> 方法用来关闭窗口。<br>检验弹出窗口是否被屏蔽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bloked=false;</span><br><span class="line">try&#123;</span><br><span class="line">    var wroxWin=window.open(&quot;http://www.baidu.com&quot;,&apos;_blank&apos;);</span><br><span class="line">    if(wroxWin==null)&#123;</span><br><span class="line">        bloked=true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(ex)&#123;</span><br><span class="line">    bloked=true;</span><br><span class="line">&#125;</span><br><span class="line">if(bloked)&#123;</span><br><span class="line">    alert(&quot;The popup was bloked!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><p>setTimeout() 方法接受两个参数：要执行的代码和以毫秒表示的时间。<br>clearTimeout() 方法是取消超时调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var oBtn=document.getElementById(&apos;btn&apos;);</span><br><span class="line">var timeoutId=setTimeout(function()&#123;</span><br><span class="line">    alert(&quot;hello!&quot;);</span><br><span class="line">&#125;,1000);</span><br><span class="line">clearTimeout(timeoutId);</span><br></pre></td></tr></table></figure></p><p>设置间歇调用的方法是setInterval()。它接受的参数也是：要执行的代码和以毫秒表示的时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var num=0;</span><br><span class="line">var max=10;</span><br><span class="line">var intervalId=null;</span><br><span class="line">function incrementNumber()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    if(num==max)&#123;</span><br><span class="line">        clearInterval(intervalId);</span><br><span class="line">        alert(&quot;Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId=setInterval(incrementNumber,1000);</span><br><span class="line">var num=0;</span><br><span class="line">var max=10;</span><br><span class="line">function incrementNumber()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    if(num&lt;max)&#123;</span><br><span class="line">        setTimeout(incrementNumber,1000);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        alert(&quot;Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber,1000);</span><br></pre></td></tr></table></figure></p><p>这两种表达方式的效果都是一样的。不过最好不要使用间歇调用。</p><h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><p>alert(),confirm(),prompt()方法可以调用系统对话框向用户显示信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result=prompt(&quot;What is your name?&quot;);</span><br><span class="line">if(result)&#123;</span><br><span class="line">    alert(&quot;welcome,&quot;+result);//welcome,...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>查询字符串参数，在开发的时候经常用到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function getQueryStringArgs()&#123;</span><br><span class="line">  //取得查询字符串并去掉开头的问号</span><br><span class="line">  var qs=(location.search.length &gt;0?location.search.substring(1)：&apos;&apos;);</span><br><span class="line">  //保存数据的对象</span><br><span class="line">  arg=&#123;&#125;;</span><br><span class="line">  var items=qs.length?qs.split(&apos;&amp;&apos;):[],</span><br><span class="line">      item=null,</span><br><span class="line">      name=null,</span><br><span class="line">      //在for循环中使用</span><br><span class="line">      i=0,</span><br><span class="line">      len=items.length;</span><br><span class="line">  //逐个将每一项添加到args对象中</span><br><span class="line">  for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">     item=items[i].split(&quot;=&quot;);</span><br><span class="line">     name=decodeURIComponent(item[0]);</span><br><span class="line">     value=decodeURIComponent(item[1]);</span><br><span class="line">     if(name.length)&#123;</span><br><span class="line">        args[name]=value;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如：要查询的字符串是?q=javascript&amp;num=10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var args=getQueryStringArgs();</span><br><span class="line">alert(args[&quot;q&quot;]);//javascript</span><br><span class="line">alert(args[&quot;num&quot;]);//10</span><br></pre></td></tr></table></figure></p><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location.assign(&quot;http://www.baidu.com&quot;);</span><br><span class="line">window.location=&quot;http://www.baidu.com&quot;;</span><br><span class="line">location.href=&quot;http://www.baidu.com&quot;;</span><br><span class="line">这三种表达方式效果都是一样，打开百度的网页。</span><br><span class="line">另外修改location的hash,search,hostname,pathname,port属性可以改变当前加载的页面。</span><br><span class="line">假设初始的URL为http://www.baidu.com/win/</span><br><span class="line">//修改为：http://www.baidu.com/win/#section1</span><br><span class="line">location.hash = “#section1”;</span><br><span class="line">//修改为：http://www.baidu.com/win/?q=JavaScript</span><br><span class="line">location.search = “?q=javascript”;</span><br><span class="line">//修改为：http://www.yahoo.com/win/</span><br><span class="line">location.hostname = “www.yahoo.com”</span><br><span class="line">//修改为：http://www.baidu.com/win/mydir</span><br><span class="line">location.pathname = “mydir”</span><br><span class="line">//修改为：http://www.baidu.com:8080/win/</span><br><span class="line">location.port = “8080”</span><br></pre></td></tr></table></figure><p>replace()函数在设置URL方面与location的href属性或assign函数完全一样，但是它会删除history对象的地址列表中的URL，从而使Go或back等函数无法导航。<br>reload()函数是用于重新加载当前显示的页面。一般最好将reload() 放在代码的最后一行。</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history() 中使用最常的就是go()方法。<br>后退一页：history.go(-1)<br>前进一页：history.go(1)<br>前进两页：history.go(2)<br>也可以指定网页跳转：history.go(“url”),后退：history().back(),前进：history.forward()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;window对象&quot;&gt;&lt;a href=&quot;#window对象&quot; class=&quot;headerlink&quot; title=&quot;window对象&quot;&gt;&lt;/a&gt;window对象&lt;/h2&gt;&lt;p&gt;在全局作用域中声明的变量、函数都会变成window对象的属性和方法。全局变量不能通过dele
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="BOM" scheme="https://qiuyuxiu.github.io/MyBlog/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包问题</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript闭包问题/</id>
    <published>2017-06-17T05:23:11.000Z</published>
    <updated>2018-06-09T07:19:46.419Z</updated>
    
    <content type="html"><![CDATA[<p>函数的闭包：有权访问另一个函数作用域中的变量的函数。常见方式：在一个函数内部创建另一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertuName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1=object1[propertuName];</span><br><span class="line">        var value2=object2[propertuName];</span><br><span class="line">        if(value1&lt;value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1&gt;value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createFunction()&#123;</span><br><span class="line">    var result=new Array();</span><br><span class="line">    for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">        result[i]=function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">var funcs = createFunction();</span><br><span class="line">for (var i=0; i &lt; funcs.length; i++)&#123;</span><br><span class="line">    document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>createFunction()函数返回一个数组。表面上看，似乎每个函数都应该返回自己的索引值，但事实并非如此，事实上每个函数的返回值都是10.因为每个函数的作用域链中都包含着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值就是10，此时每个函数都引用着保存变量i的同一个变量对象，所以每个函数返回后都是10。</p><p>创建另一个匿名函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createFunction() &#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function(num) &#123;</span><br><span class="line">            return function() &#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">var funcs = createFunction();</span><br><span class="line">for(var i = 0; i &lt; funcs.length; i++) &#123;</span><br><span class="line">    document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在重写了前面的createFunction()函数后，每个函数就会返回各自不同的索引值了。在这里，我们没有直接把闭包赋值给数值，而是定义了一个匿名函数，并将立即执行该函数的结果赋值给数组。这里的匿名函数有一个参数num,也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数参数按值传递的，所以就会将变量i的当前值复制给参数num。而在这个匿名函数内部，有创建并返回了一个访问num的闭包。这样依赖，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了。</p><p>闭包的作用：一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;　　　　</span><br><span class="line">    var n = 9;  　　　　</span><br><span class="line">    Add = function() &#123;</span><br><span class="line">        n += 1</span><br><span class="line">    &#125;   　　　　</span><br><span class="line">    function f2() &#123;　　　　　　</span><br><span class="line">        alert(n);　　　　</span><br><span class="line">    &#125;   　　　　</span><br><span class="line">    return f2;  　　</span><br><span class="line">&#125;　　</span><br><span class="line">var result = f1();　　</span><br><span class="line">result(); // 9　</span><br><span class="line">Add();　　</span><br><span class="line">result(); // 10</span><br></pre></td></tr></table></figure></p><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是9，第二次的值是10。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。一般将其设置为null可以删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function assignHandler()&#123;</span><br><span class="line">    var element=document.getElementById(&quot;someElement&quot;);</span><br><span class="line">    var id=element.id;</span><br><span class="line">    element.onclick=function()&#123;</span><br><span class="line">         alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    element=null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量的作用域<br>要理解闭包，首先必须理解Javascript特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量，在函数外部自然无法读取函数内的局部变量。</p><p>用闭包模拟私有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var Counter = (function() &#123;</span><br><span class="line">  var privateCounter = 0;</span><br><span class="line">  function changeBy(val) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    increment: function() &#123;</span><br><span class="line">      changeBy(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: function() &#123;</span><br><span class="line">      changeBy(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(Counter.value()); /* logs 0 */</span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line">console.log(Counter.value()); /* logs 2 */</span><br><span class="line">Counter.decrement();</span><br><span class="line">console.log(Counter.value()); /* logs 1 */</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数的闭包：有权访问另一个函数作用域中的变量的函数。常见方式：在一个函数内部创建另一个函数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="闭包" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Function类型</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-Function%E7%B1%BB%E5%9E%8B/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-Function类型/</id>
    <published>2017-06-17T03:43:27.000Z</published>
    <updated>2018-06-09T07:17:21.949Z</updated>
    
    <content type="html"><![CDATA[<p>作为值的函数：不仅可以像传递参数一样传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction,someArgument)&#123;</span><br><span class="line">    return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line">function add10(num)&#123;</span><br><span class="line">    return num+10;</span><br><span class="line">&#125;</span><br><span class="line">var result=callSomeFunction(add10,10);</span><br><span class="line">document.write(result);//20</span><br><span class="line">function getGreeting(name)&#123;</span><br><span class="line">    return &quot;hello, &quot;+name;</span><br><span class="line">&#125;</span><br><span class="line">var result2=callSomeFunction(getGreeting,&quot;Nike&quot;);</span><br><span class="line">document.write(result2);//hello, Nike</span><br></pre></td></tr></table></figure></p><p>sort()方法用到这种从一个函数返回另一个函数的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertuName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1=object1[propertuName];</span><br><span class="line">        var value2=object2[propertuName];</span><br><span class="line">        if(value1&lt;value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1&gt;value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var data=[&#123;name:&quot;Zachary&quot;,age:28&#125;,&#123;name:&quot;Nick&quot;,age:29&#125;];</span><br><span class="line">data.sort(createComparisonFunction(&quot;name&quot;));</span><br><span class="line">document.write(data[0].name);//Nick</span><br><span class="line">data.sort(createComparisonFunction(&quot;age&quot;));</span><br><span class="line">document.write(data[0].name);//Zachary</span><br></pre></td></tr></table></figure></p><p>函数内部属性：arguments 和 this<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num*factorial(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result=factorial(9);</span><br><span class="line">alert(result);</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num*arguments.callee(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result=factorial(9);</span><br><span class="line">alert(result);</span><br></pre></td></tr></table></figure></p><p>这两个函数执行的结果一样，都为362880。<br>函数属性和方法：<br>每个函数都包含两个属性：length和prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayName(name)&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">&#125;</span><br><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">    alert(&quot;hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">alert(sayName.length);//1</span><br><span class="line">alert(sum.length);//2</span><br><span class="line">alert(sayHi.length);//0</span><br></pre></td></tr></table></figure></p><p>每个函数包含两个非继承而来的方法apply()和call()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">function callSum2(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,[num1,num2]);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(10,10));//20</span><br><span class="line">alert(callSum2(10,10));//20</span><br></pre></td></tr></table></figure></p><p>call() 方法第二个参数是其余参数直接传递给函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1,num2)&#123;</span><br><span class="line">    return sum.call(this,num1,num2);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(10,10));//20</span><br></pre></td></tr></table></figure></p><p>在讨论javascript的继承中也用到了call()方法。</p><p>bind() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.color=&quot;red&quot;;</span><br><span class="line">var o=&#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor=sayColor.bind(o);</span><br><span class="line">objectSayColor();//blue</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为值的函数：不仅可以像传递参数一样传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="Function类型" scheme="https://qiuyuxiu.github.io/MyBlog/tags/Function%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 继承</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-%E7%BB%A7%E6%89%BF/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-继承/</id>
    <published>2017-06-17T02:27:36.000Z</published>
    <updated>2018-06-09T07:13:25.657Z</updated>
    
    <content type="html"><![CDATA[<p>原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property=true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty=false;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype=new SuperType();//继承SuperType</span><br><span class="line">SubType.prototype.getSubValue=function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.getSubValue());//false</span><br><span class="line">alert(instance.getSuperValue());//true</span><br></pre></td></tr></table></figure></p><p>注意：子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property=true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty=false;</span><br><span class="line">&#125;</span><br><span class="line">//继承SuperType</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">//添加新方法</span><br><span class="line">SubType.prototype.getSubValue=function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">//重写超类型中的方法</span><br><span class="line">SubType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.getSubValue());//false</span><br><span class="line">alert(instance.getSuperValue());//false</span><br><span class="line">不能使用对象字面量创建原型方法。</span><br></pre></td></tr></table></figure></p><p>原型链的问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">&#125;</span><br><span class="line">//继承</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">var instance=new SubType();</span><br><span class="line">instance.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance.colors);//red,blue,green,black</span><br><span class="line">var instance2=new SubType();</span><br><span class="line">alert(instance2.colors);//red,blue,green,black</span><br></pre></td></tr></table></figure></p><p>这个问题和在创建对象的时候也有，因为colors是共享属性。</p><p>借用构造函数：使用apply() 和call() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    //继承</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">instance.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance.colors);//red,blue,green,black</span><br><span class="line">var instance2=new SubType();</span><br><span class="line">alert(instance2.colors);//red,blue,green</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    //继承</span><br><span class="line">    SuperType.call(this,&quot;Nick&quot;);</span><br><span class="line">    this.age=29;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.name);//Nick</span><br><span class="line">alert(instance.age);//29</span><br></pre></td></tr></table></figure></p><p>组合继承：将原型链和借用构造函数的技术组合到一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    thia.name=name;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName=function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">//继承方法</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line">SubType.prototype.sayAge=function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var instance1=new SubType(&quot;Nick&quot;,29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);//red,blue,green,black</span><br><span class="line">instance1.sayName();//Nick</span><br><span class="line">instance1.sayAge();//29</span><br><span class="line">var instance2=new SubType(&quot;Greg&quot;,27);</span><br><span class="line">alert(instance1.colors);//red,blue,green</span><br><span class="line">instance1.sayName();//Greg</span><br><span class="line">instance1.sayAge();//27</span><br></pre></td></tr></table></figure></p><p>还有其他的一些继承方式比较少见的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="继承" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面向对象</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-面向对象/</id>
    <published>2017-06-17T01:23:49.000Z</published>
    <updated>2018-06-09T07:09:26.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>要修改对象的属性的默认的特性，必须使用Object.defineProperty() 方法。这个方法接受三个参数：属性所在的对象，属性的名字，一个描述符对象。描述符对象的属性必须是configurable,enumberable,writable,value。在不指定情况下，configurable,enumberable,writable这三个属性都是默认为false。<br>configurable设置为false 表示不能从对象中删除属性。writable设置为false表示是只读的，不能对属性进行赋值。enumberable表示能否通过for-in循环返回属性。</p><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>在读取访问器属性时，会调用getter函数；在写入访问器属性时，会调用setter函数并传入新值。<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;</span><br><span class="line">    _year:2004,</span><br><span class="line">    edition:1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function(newValue)&#123;</span><br><span class="line">        if(newValue&gt;2004)&#123;</span><br><span class="line">            this._year=newValue;</span><br><span class="line">            this.edition+=newValue-2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year=2005;</span><br><span class="line">alert(book.edition);//2</span><br></pre></td></tr></table></figure></p><p>定义多个属性：Object.defineProperties()方法。<br>读取属性的特征：Object.getOwnPropertyDescriptor()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        value:2004,</span><br><span class="line">        writable: true//这个必须写，不然不能下面book.year没有启用而起作用弹出2007，不然就弹出2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        value:1</span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        get:function()&#123;</span><br><span class="line">            return this._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function(newValue)&#123;</span><br><span class="line">            if(newValue&gt;2004)&#123;</span><br><span class="line">                this._year=newValue;</span><br><span class="line">                this.edition+=newValue-2004;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var descriptor=Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);</span><br><span class="line">alert(descriptor.value);//2004</span><br><span class="line">alert(descriptor.configurable);//false</span><br><span class="line">book.year=2007;</span><br><span class="line">alert(book._year);//2007</span><br></pre></td></tr></table></figure></p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>1.工厂模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o=new Object();</span><br><span class="line">    o.name=name;</span><br><span class="line">    o.age=age;</span><br><span class="line">    o.job=job;</span><br><span class="line">    o.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1=createPerson(&quot;Nick&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.sayName();//Nick</span><br><span class="line">alert(person2.name);//Greg</span><br></pre></td></tr></table></figure></p><p>2.构造函数模式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.job=job;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1=new Person(&quot;Nick&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.sayName();//Nick</span><br><span class="line">alert(person2.name);//Greg</span><br></pre></td></tr></table></figure></p><p>3.原型模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=&quot;Nike&quot;;</span><br><span class="line">Person.prototype.age=29;</span><br><span class="line">Person.prototype.job=&quot;Engineer&quot;;</span><br><span class="line">Person.prototype.sayName=function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">person1.sayName();//Nike</span><br><span class="line">var person2=new Person();</span><br><span class="line">person2.sayName();//Nike</span><br><span class="line">alert(person1.sayName==person2.sayName);//true</span><br><span class="line">hasOwnProperty() 方法可以检测一个属性是否存在于实例中，还是存在于原型中。如果存在于对象实例中，则返回true。</span><br><span class="line">hasPrototypeProperty() 方法可以检测一个属性是否存在于实例中，还是存在于原型中。如果存在于对象原型中，则返回true。</span><br><span class="line">Object.keys() 方法接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</span><br></pre></td></tr></table></figure></p><p>更简单的原型语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  name: &quot;Nike&quot;,</span><br><span class="line">  age: 29,</span><br><span class="line">  job: &quot;Engineer&quot;,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>原型对象的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &quot;Nike&quot;,</span><br><span class="line">  job: &quot;Engineer&quot;,</span><br><span class="line">  friends: [&quot;Shelby&quot;,&quot;Court&quot;],</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">var person2=new Person();</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);//Shelby,Court,Van</span><br><span class="line">alert(person2.friends);//Shelby,Court,Van</span><br><span class="line">alert(person1.friends==person2.friends);//true</span><br></pre></td></tr></table></figure></p><p>可以看到当改变一个对象的friends时，其他的对象的friends也跟着改变friends数组存在于person.prototype中，而不是存在于person1中，所以当改变person1的friends时候，person2的friends也变化。</p><p>4.组合使用构造函数模式和原型模式：构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">  this.job=job;</span><br><span class="line">  this.friends=[&quot;Shelby&quot;,&quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1=new Person(&quot;Nike&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);//Shelby,Court,Van</span><br><span class="line">alert(person2.friends);//Shelby,Court</span><br><span class="line">alert(person1.friends==person2.friends);//false</span><br><span class="line">alert(person1.sayName==person2.sayName);//true</span><br></pre></td></tr></table></figure></p><p>5.动态原型模式<br>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;) &#123; //在sayName()方法不存在的情况下，才会将它添加到原型中。instanceof操作符也可以</span><br><span class="line">        Person.prototype.sayName = function() &#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person(&quot;Nike&quot;, 29, &quot;Engineer&quot;);</span><br><span class="line">friend.sayName();//Nike</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h2&gt;&lt;p&gt;要修改对象的属性的默认的特性，必须使用Object.defineProperty() 方法。这个方法接受三个参数：属性所在的
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
