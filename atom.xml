<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>有关于前端学习的个人博客</subtitle>
  <link href="/MyBlog/atom.xml" rel="self"/>
  
  <link href="https://qiuyuxiu.github.io/MyBlog/"/>
  <updated>2018-08-17T03:14:23.000Z</updated>
  <id>https://qiuyuxiu.github.io/MyBlog/</id>
  
  <author>
    <name>Daisy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安卓必学几点</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/08/17/%E5%AE%89%E5%8D%93%E5%BF%85%E5%AD%A6%E5%87%A0%E7%82%B9/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/08/17/安卓必学几点/</id>
    <published>2018-08-17T03:06:15.000Z</published>
    <updated>2018-08-17T03:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h4><ul><li>activity 生命周期（需熟悉，234可后期学）</li><li>BroadcastReceive广播接收器:</li><li>Service 服务:</li><li>content provider </li></ul><h4 id="Android五大布局-前三个常用需熟悉，-后两个需了解"><a href="#Android五大布局-前三个常用需熟悉，-后两个需了解" class="headerlink" title="Android五大布局  前三个常用需熟悉， 后两个需了解"></a>Android五大布局  前三个常用需熟悉， 后两个需了解</h4><ul><li>LinearLayout(线性布局)</li><li>RelativeLayout(相对布局)</li><li>FrameLayout(框架布局)</li><li>AbsoluteLayout(绝对布局)</li><li>TableLayout(表格布局)</li></ul><h4 id="常用控件（需熟悉）"><a href="#常用控件（需熟悉）" class="headerlink" title="常用控件（需熟悉）"></a>常用控件（需熟悉）</h4><ul><li>ImageView</li><li>TextView</li><li>CheckBox</li><li>Button </li><li>ProgressBar</li><li>EditText</li><li>RadioButton与RadioGroup</li><li>RecyleView（列表）</li></ul><h4 id="选择器selector-xml的属性"><a href="#选择器selector-xml的属性" class="headerlink" title="选择器selector.xml的属性"></a>选择器selector.xml的属性</h4><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>ValueAnimation<br><a href="http://www.runoob.com/w3cnote/android-tutorial-valueanimator.html" target="_blank" rel="noopener">动画新手教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;四大组件&quot;&gt;&lt;a href=&quot;#四大组件&quot; class=&quot;headerlink&quot; title=&quot;四大组件&quot;&gt;&lt;/a&gt;四大组件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;activity 生命周期（需熟悉，234可后期学）&lt;/li&gt;
&lt;li&gt;BroadcastReceive广播接收
      
    
    </summary>
    
      <category term="安卓" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E5%AE%89%E5%8D%93/"/>
    
    
      <category term="安卓" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>http三个版本</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/http%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/http三个版本/</id>
    <published>2018-06-08T08:52:34.000Z</published>
    <updated>2018-06-09T15:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP1-0-amp-HTTP1-1"><a href="#HTTP1-0-amp-HTTP1-1" class="headerlink" title="HTTP1.0 &amp; HTTP1.1"></a>HTTP1.0 &amp; HTTP1.1</h2><p>1.长连接<br>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接,参数为keep-alive。<br>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p><p>2.节约带宽<br>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401(无权限)。客户端如果接受到100，才开始把请求body发送到服务器。<br>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分,这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可,这是支持文件断点续传的基础。</p><p>3.HOST域<br>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p><h2 id="HTTP1-1-HTTP-2-0主要区别"><a href="#HTTP1-1-HTTP-2-0主要区别" class="headerlink" title="HTTP1.1 HTTP 2.0主要区别"></a>HTTP1.1 HTTP 2.0主要区别</h2><p>1.多路复用<br>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。<br>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。<br>当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。<br>TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求</p><p>2.数据压缩<br>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><p>3.服务器推送<br>当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。<br>服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</p><p>4.加载速度很快</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP1-0-amp-HTTP1-1&quot;&gt;&lt;a href=&quot;#HTTP1-0-amp-HTTP1-1&quot; class=&quot;headerlink&quot; title=&quot;HTTP1.0 &amp;amp; HTTP1.1&quot;&gt;&lt;/a&gt;HTTP1.0 &amp;amp; HTTP1.1&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="HTTP" scheme="https://qiuyuxiu.github.io/MyBlog/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://qiuyuxiu.github.io/MyBlog/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>长连接&amp;短连接&amp;长轮询&amp;短轮询</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5-%E9%95%BF%E8%BD%AE%E8%AF%A2-%E7%9F%AD%E8%BD%AE%E8%AF%A2/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/长连接-短连接-长轮询-短轮询/</id>
    <published>2018-06-08T08:52:19.000Z</published>
    <updated>2018-06-09T15:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="长连接、短连接"><a href="#长连接、短连接" class="headerlink" title="长连接、短连接"></a>长连接、短连接</h2><p>在HTTP/1.0中默认使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。<br>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<br><code>Connection:keep-alive</code><br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h2 id="长连接和短连接的优点和缺点"><a href="#长连接和短连接的优点和缺点" class="headerlink" title="长连接和短连接的优点和缺点"></a>长连接和短连接的优点和缺点</h2><p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。<br>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。<br>长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。</p><h2 id="长轮询、短轮询"><a href="#长轮询、短轮询" class="headerlink" title="长轮询、短轮询"></a>长轮询、短轮询</h2><p>在长轮询机制中，客户端像传统轮询一样从服务器请求数据。然而，如果服务器没有可以立即返回给客户端的数据，则不会立刻返回一个空结果，而是保持这个请求等待数据到来（或者恰当的超时），之后将数据作为结果返回给客户端。<br>很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。<br>轮询：客户端定时向服务器发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>优点：后端程序编写比较容易。<br>缺点：请求中有大半是无用，浪费带宽和服务器资源。<br>实例：适于小型应用。<br>长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br>优点：在无消息的情况下不会频繁的请求。<br>缺点：服务器hold连接会消耗资源。<br>实例：WebQQ、Hi网页版、Facebook IM。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;长连接、短连接&quot;&gt;&lt;a href=&quot;#长连接、短连接&quot; class=&quot;headerlink&quot; title=&quot;长连接、短连接&quot;&gt;&lt;/a&gt;长连接、短连接&lt;/h2&gt;&lt;p&gt;在HTTP/1.0中默认使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就
      
    
    </summary>
    
      <category term="长连接&amp;短连接&amp;长轮询&amp;短轮询" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5-%E9%95%BF%E8%BD%AE%E8%AF%A2-%E7%9F%AD%E8%BD%AE%E8%AF%A2/"/>
    
    
      <category term="长连接&amp;短连接&amp;长轮询&amp;短轮询" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5-%E9%95%BF%E8%BD%AE%E8%AF%A2-%E7%9F%AD%E8%BD%AE%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>JSONP</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/05/08/JSONP/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/05/08/JSONP/</id>
    <published>2018-05-08T08:52:46.000Z</published>
    <updated>2018-06-09T15:36:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>手写Jsonp，Jsonp是跨域请求的一种常用的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(function (window,document) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  var jsonp = function(url,data,callback)&#123;</span><br><span class="line">    //1 挂载回调函数</span><br><span class="line">    var fnSuffix = Math.random().toString().replace(&apos;.&apos;,&apos;&apos;);</span><br><span class="line">    var cbFuncName = &apos;my_json_cd_&apos; + fnSuffix;</span><br><span class="line">    //将函数挂载在全局环境的方式不推荐  使用cbs.my_json_cb_</span><br><span class="line">    window[cbFuncName] = callback;</span><br><span class="line">    //2 将data转化成url字符串的形式</span><br><span class="line">    var querystring = url.indexOf(&apos;?&apos;)==-1?&apos;?&apos;:&apos;&amp;&apos;;</span><br><span class="line">    for(var key in data)&#123;</span><br><span class="line">      querystring += key + &apos;=&apos; +data[key]+&apos;&amp;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    //3 处理url地址中的回调参数</span><br><span class="line">    querystring += &apos;callback=&apos; + cbFuncName;</span><br><span class="line">    //4 创建一个script的标签</span><br><span class="line">    var scriptElement = document.createElement(&apos;script&apos;);</span><br><span class="line">    scriptElement.src = url + querystring;</span><br><span class="line">    //5 将script标签放到页面中</span><br><span class="line">    document.body.appendChild(scriptElement);</span><br><span class="line">  &#125;;</span><br><span class="line">  window.$jsonp = jsonp;</span><br><span class="line">&#125;)(window,document);</span><br><span class="line">//实现</span><br><span class="line">// (function()&#123;</span><br><span class="line">//   $jsonp(//地址</span><br><span class="line">//     &apos;http://api.douban.com/v2/movie/in_theaters&apos;,</span><br><span class="line">//     //传递的参数</span><br><span class="line">//     &#123;</span><br><span class="line">//       count:10,start:5</span><br><span class="line">//     &#125;,</span><br><span class="line">//     //回调函数</span><br><span class="line">//     function(data)&#123;</span><br><span class="line">//       document.getElementById(&apos;result&apos;).innerHTML=JSON.stringify(data);</span><br><span class="line">//     &#125;</span><br><span class="line">//   );</span><br><span class="line">// &#125;)();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;手写Jsonp，Jsonp是跨域请求的一种常用的方式。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
      <category term="JSONP" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JSONP/"/>
    
    
      <category term="JSONP" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>手写promise</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/03/21/%E6%89%8B%E5%86%99promise/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/03/21/手写promise/</id>
    <published>2018-03-21T08:52:57.000Z</published>
    <updated>2018-06-09T15:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>promise规范在前端中非常重要，特别是异步请求的时候。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">function Defer(executor)&#123;</span><br><span class="line">    if(!(this instanceof Defer))&#123;</span><br><span class="line">        throw &apos;Defer is a constructor and should be called width &quot;new&quot; keyword&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof executor !== &apos;function&apos;)&#123;</span><br><span class="line">        throw &apos;Defer params must be a function&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    this.thenCache = [];//&#123;resolve:,reject:&#125;</span><br><span class="line">    this.errorHandle = null;</span><br><span class="line">    this.status = &apos;pendding&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line">    this.rejectReason = null;</span><br><span class="line">    var self = this;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            executor.call(self, self.resolve.bind(self), self.reject.bind(self));//传递resolve，reject方法</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            self.reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,0);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Defer.prototype.resolve = function(value)&#123;</span><br><span class="line">    this.status = &apos;resolved&apos;;</span><br><span class="line">    this.value = value;</span><br><span class="line">    this.triggerThen();</span><br><span class="line">&#125;;</span><br><span class="line">Defer.prototype.reject = function(reason)&#123;</span><br><span class="line">    this.status = &apos;rejected&apos;;</span><br><span class="line">    this.rejectReason = reason;</span><br><span class="line">    this.triggerThen();</span><br><span class="line">&#125;;</span><br><span class="line">Defer.prototype.then = function(resolve,reject)&#123;</span><br><span class="line">    var todo = &#123;resolve:resolve,reject:reject&#125;;</span><br><span class="line">    this.thenCache.push(todo);</span><br><span class="line">    return this;</span><br><span class="line">&#125;;</span><br><span class="line">Defer.prototype.triggerThen = function()&#123;</span><br><span class="line">    var current = this.thenCache.shift();</span><br><span class="line">    var res = null;</span><br><span class="line">    if(!current &amp;&amp; this.status === &apos;resolved&apos;)&#123;//成功解析并读取完then cache</span><br><span class="line">        return this;</span><br><span class="line">    &#125;else if(!current &amp;&amp; this.status === &apos;rejected&apos;)&#123;//解析失败并读取完then cache，直接调用errorHandle</span><br><span class="line">        if(this.errorHandle)&#123;</span><br><span class="line">            this.value = this.errorHandle.call(undefined, this.rejectReason);</span><br><span class="line">            this.status= &apos;resolved&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;;</span><br><span class="line">    if(this.status === &apos;resolved&apos;)&#123;</span><br><span class="line">        res = current.resolve;</span><br><span class="line">    &#125;else if(this.status === &apos;rejected&apos;)&#123;</span><br><span class="line">        res = current.reject;</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof res === &apos;function&apos;)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            this.value = res.call(undefined, this.value || this.rejectReason);//重置promise的value</span><br><span class="line">            this.status = &apos;resolved&apos;;</span><br><span class="line">            this.triggerThen();//继续执行then链</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            this.status = &apos;rejected&apos;;//异常，则promise为reject</span><br><span class="line">            this.rejectReason = e;</span><br><span class="line">            return this.triggerThen();//触发then链</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;//不是函数则忽略</span><br><span class="line">        this.triggerThen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Defer.prototype.catch = function(fn)&#123;</span><br><span class="line">    if(typeof fn === &apos;function&apos;)&#123;</span><br><span class="line">        this.errorHandle = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function test() &#123;</span><br><span class="line">    debugger;</span><br><span class="line">    return new Defer(function(res,rej)&#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            res(1);</span><br><span class="line">        &#125;,1000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test().then(function(value)&#123;</span><br><span class="line">    console.log(&apos;resolve then 1&apos;,value);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;).then(function (value) &#123;</span><br><span class="line">    console.log(&apos;resolve then 2&apos;,value);</span><br><span class="line">    throw 2;</span><br><span class="line">&#125;).catch(function (e) &#123;</span><br><span class="line">    console.log(&apos;error&apos;,e);</span><br><span class="line">&#125;);</span><br><span class="line">function test2()&#123;</span><br><span class="line">    return new Defer(function(res,rej)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            rej(1);</span><br><span class="line">        &#125;,1000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">test2().then(null, function(value)&#123;</span><br><span class="line">    console.log(&apos;reject then 1&apos;, value);</span><br><span class="line">    throw &apos;error 1&apos;</span><br><span class="line">&#125;).then(null, function(value)&#123;</span><br><span class="line">    console.log(&apos;reject then 2&apos;, value);</span><br><span class="line">    throw &apos;error 2&apos;;</span><br><span class="line">&#125;).catch(function(e)&#123;</span><br><span class="line">    console.log(&apos;error&apos;,e);</span><br><span class="line">&#125;);</span><br><span class="line">//结果:</span><br><span class="line">//reject then 1 1</span><br><span class="line">//reject then 2 error 2</span><br><span class="line">//error erro 2</span><br><span class="line">test2().then(null, function(value)&#123;</span><br><span class="line">    console.log(&apos;reject then 1&apos;, value);</span><br><span class="line">    throw &apos;throw error from then 1&apos;;</span><br><span class="line">&#125;).then(function(value)&#123;</span><br><span class="line">    console.log(&apos;resolve then 2&apos;, value);</span><br><span class="line">&#125;).catch(function(e)&#123;</span><br><span class="line">    console.log(&apos;error&apos;,e);</span><br><span class="line">&#125;);</span><br><span class="line">//结果:</span><br><span class="line">//reject then 1 1</span><br><span class="line">//error throw error from then 1</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;promise规范在前端中非常重要，特别是异步请求的时候。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="promise" scheme="https://qiuyuxiu.github.io/MyBlog/categories/promise/"/>
    
    
      <category term="promise" scheme="https://qiuyuxiu.github.io/MyBlog/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>内存泄漏问题</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/03/01/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/03/01/内存泄漏问题/</id>
    <published>2018-03-01T08:53:07.000Z</published>
    <updated>2018-06-09T15:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>借鉴于：<br><a href="http://www.cnblogs.com/chuaWeb/p/5196330.html" target="_blank" rel="noopener">前端内存泄漏探讨</a><br><a href="https://www.jb51.net/article/75292.htm" target="_blank" rel="noopener">垃圾回收机制与内存管理</a></p><ol><li>在 IE7、IE8 中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，比如var a = document.getElementById(“#a”)，垃圾收集系统则不会发现它们之间的循环关系,因为IE的DOM回收机制和JS回收机制不是同一个。js回收机制分两种：标记清除和引用计数，引用计数对循环引用的垃圾回收会出现内存泄漏，而IE的DOM回收机制便是采用引用计数的。IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变。</li><li>标记清除:<br>js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</li><li>引用计数<br>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</li><li>垃圾回收机制—GC<br>Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。<br>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。<br>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</li><li>内存泄露的形式：<br>循环引用（Circular References） - 当 IE 浏览器的 COM 组件与脚本引擎对象之间相互引用时，将导致内存泄露，这是最常见的形式。<br>闭包（Closures） - 闭包是循环引用的特殊形式，也是目前 Web 架构中使用最多的一种语言特性。闭包很容易被发现，因为它们依赖于特定的语言关键字，可以通过简单的搜索来查找。<br>页面交叉泄露（Cross-Page Leaks） - 页面交叉泄漏其实是一种较小的泄漏，它通常在你浏览过程中，由于内部对象 book-keeping 引起。我们将讨论 DOM 插入顺序问题，在示例中你将发现只需要微小的改动就可以避免 book-keeping 对象的产生。<br>伪泄露（Pseudo-Leaks） — 严格来说并不算真正的内存泄露，不过如果你不了解它，你将会在可用内存越来越少时非常懊恼。为了演示这个问题，我们将通过重写 script 元素中的内容来引发大量内存的“泄漏”。</li><li>es6中weakSet，weakMap可以解决内存泄露问题，弱引用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;借鉴于：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chuaWeb/p/5196330.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端内存泄漏探讨&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jb51.
      
    
    </summary>
    
      <category term="内存泄漏" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
    
      <category term="内存泄漏" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>jQuery多种插件使用说明</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/02/03/jQuery%E5%A4%9A%E7%A7%8D%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/02/03/jQuery多种插件使用说明/</id>
    <published>2018-02-03T04:17:55.000Z</published>
    <updated>2018-06-09T15:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日历插件"><a href="#日历插件" class="headerlink" title="日历插件"></a>日历插件</h2><p>1.<a href="http://www.my97.net/" target="_blank" rel="noopener">WdatePicker.js</a><br>下载WdatePicker插件：<a href="http://www.my97.net/" target="_blank" rel="noopener">点击下载</a><br>使用说明：<br>引入js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;WdatePicker.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>常规：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;d11&quot; type=&quot;text&quot; onClick=&quot;WdatePicker()&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>图标触发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;d12&quot; type=&quot;text&quot;/&gt;</span><br><span class="line">&lt;img onclick=&quot;WdatePicker(&#123;el:&apos;d12&apos;&#125;)&quot; src=&quot;../skin/datePicker.gif&quot; width=&quot;16&quot; height=&quot;22&quot; align=&quot;absmiddle&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>注意:只需要传入控件的id即可</p><p>文档见<a href="http://www.my97.net/dp/demo/index.htm" target="_blank" rel="noopener">WdatePicker文档</a></p><h2 id="全屏滚动插件"><a href="#全屏滚动插件" class="headerlink" title="全屏滚动插件"></a>全屏滚动插件</h2><p>1.<a href="http://www.dowebok.com/77.html" target="_blank" rel="noopener">fullPage.js</a><br>下载fullPage插件：<a href="http://www.dowebok.com/77.html" target="_blank" rel="noopener">点击下载</a><br>使用说明：<br>引入文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/jquery.fullPage.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- jquery.easings.min.js 用于 easing 参数，也可以使用完整的 jQuery UI 代替，如果不需要设置 easing 参数，可去掉改文件 --&gt;</span><br><span class="line">&lt;script src=&quot;js/jquery.easings.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 如果 scrollOverflow 设置为 true，则需要引入 jquery.slimscroll.min.js，一般情况下不需要 --&gt;</span><br><span class="line">&lt;script src=&quot;js/jquery.slimscroll.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/jquery.fullPage.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>HTML:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;dowebok&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;</span><br><span class="line">        &lt;h3&gt;第一屏&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;</span><br><span class="line">        &lt;h3&gt;第二屏&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;</span><br><span class="line">        &lt;h3&gt;第三屏&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;</span><br><span class="line">        &lt;h3&gt;第四屏&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>每个 section 代表一屏，默认显示“第一屏”，如果要指定加载页面时显示的“屏幕”，可以在对应的 <code>section</code> 加上 <code>class=”active”</code>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;section active&quot;&gt;第三屏&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>同时，可以在 section 内加入 slide，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;dowebok&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;第一屏&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;第二屏&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;slide&quot;&gt;第三屏的第一屏&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;slide&quot;&gt;第三屏的第二屏&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;slide&quot;&gt;第三屏的第三屏&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;slide&quot;&gt;第三屏的第四屏&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;第四屏&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>JavaScript:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $(&apos;#dowebok&apos;).fullpage();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>详细展示说明见<a href="http://www.dowebok.com/demo/2014/77/" target="_blank" rel="noopener">文档</a></p><h2 id="滚动条插件"><a href="#滚动条插件" class="headerlink" title="滚动条插件"></a>滚动条插件</h2><p>1.<a href="http://jscrollpane.kelvinluck.com/index.html#examples" target="_blank" rel="noopener">jScrollPane.js</a><br>下载jScrollPane.js插件：<a href="http://jscrollpane.kelvinluck.com/index.html#examples" target="_blank" rel="noopener">点击下载</a><br>使用说明<br>引入文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- styles needed by jScrollPane --&gt;</span><br><span class="line">&lt;link type=&quot;text/css&quot; href=&quot;style/jquery.jscrollpane.css&quot; rel=&quot;stylesheet&quot; media=&quot;all&quot; /&gt;</span><br><span class="line">&lt;!-- latest jQuery direct from google&apos;s CDN --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- the mousewheel plugin - optional to provide mousewheel support --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery.mousewheel.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- the jScrollPane script --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery.jscrollpane.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>调用接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">$(&apos;.scroll-pane&apos;).jScrollPane();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>其他的一些属性改变见：<a href="http://www.jq22.com/jquery-info14307" target="_blank" rel="noopener">文档</a></p><p>监听函数使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">$(&apos;.scroll-pane&apos;)</span><br><span class="line">.bind(</span><br><span class="line">&apos;jsp-initialised&apos;,</span><br><span class="line">function(event, isScrollable)&#123;</span><br><span class="line">console.log(&apos;Handle jsp-initialised&apos;, this,</span><br><span class="line">&apos;isScrollable=&apos;, isScrollable);</span><br><span class="line">&#125;)</span><br><span class="line">.bind(</span><br><span class="line">&apos;jsp-will-scroll-x&apos;,</span><br><span class="line">function(event, destX)&#123;</span><br><span class="line">console.log(</span><br><span class="line">&apos;Handle jsp-will-scroll-x&apos;, this,</span><br><span class="line">&apos;destX=&apos;, destX</span><br><span class="line">);</span><br><span class="line">&#125;)</span><br><span class="line">.bind(</span><br><span class="line">&apos;jsp-will-scroll-y&apos;,</span><br><span class="line">function(event, destY)&#123;</span><br><span class="line">console.log(</span><br><span class="line">&apos;Handle jsp-will-scroll-y&apos;, this,</span><br><span class="line">&apos;destY=&apos;, destY</span><br><span class="line">);</span><br><span class="line">&#125;)</span><br><span class="line">.bind(</span><br><span class="line">&apos;jsp-scroll-y&apos;,</span><br><span class="line">function(event, scrollPositionY, isAtTop, isAtBottom)&#123;</span><br><span class="line">console.log(&apos;Handle jsp-scroll-y&apos;, this,</span><br><span class="line">&apos;scrollPositionY=&apos;, scrollPositionY,</span><br><span class="line">&apos;isAtTop=&apos;, isAtTop,</span><br><span class="line">&apos;isAtBottom=&apos;, isAtBottom);</span><br><span class="line">&#125;)</span><br><span class="line">.bind(</span><br><span class="line">&apos;jsp-scroll-x&apos;,</span><br><span class="line">function(event, scrollPositionX, isAtLeft, isAtRight)&#123;</span><br><span class="line">console.log(&apos;Handle jsp-scroll-x&apos;, this,</span><br><span class="line">&apos;scrollPositionX=&apos;, scrollPositionX,</span><br><span class="line">&apos;isAtLeft=&apos;, isAtLeft,</span><br><span class="line">&apos;isAtRight=&apos;, isAtRight);</span><br><span class="line">&#125;)</span><br><span class="line">.bind(</span><br><span class="line">&apos;jsp-arrow-change&apos;,</span><br><span class="line">function(event, isAtTop, isAtBottom, isAtLeft, isAtRight)</span><br><span class="line">&#123;</span><br><span class="line">console.log(&apos;Handle jsp-arrow-change&apos;, this,</span><br><span class="line">&apos;isAtTop=&apos;, isAtTop,</span><br><span class="line">&apos;isAtBottom=&apos;, isAtBottom,</span><br><span class="line">&apos;isAtLeft=&apos;, isAtLeft,</span><br><span class="line">&apos;isAtRight=&apos;, isAtRight);</span><br><span class="line">&#125;)</span><br><span class="line">.bind(</span><br><span class="line">&apos;jsp-user-scroll-y&apos;,</span><br><span class="line">function(event, destTop, isAtTop, isAtBottom)</span><br><span class="line">&#123;</span><br><span class="line">console.log(</span><br><span class="line">&apos;Handle jsp-user-scroll-y&apos;, this,</span><br><span class="line">&apos;destTop=&apos;, destTop,</span><br><span class="line">&apos;isAtTop=&apos;, isAtTop,</span><br><span class="line">&apos;isAtBottom=&apos;, isAtBottom</span><br><span class="line">);</span><br><span class="line">&#125;)</span><br><span class="line">.bind(</span><br><span class="line">&apos;jsp-user-scroll-x&apos;,</span><br><span class="line">function(event, destLeft, isAtLeft, isAtRight)</span><br><span class="line">&#123;</span><br><span class="line">console.log(</span><br><span class="line">&apos;Handle jsp-user-scroll-x&apos;, this,</span><br><span class="line">&apos;destLeft=&apos;, destLeft,</span><br><span class="line">&apos;isAtLeft=&apos;, isAtLeft,</span><br><span class="line">&apos;isAtRight=&apos;, isAtRight</span><br><span class="line">);</span><br><span class="line">&#125;)</span><br><span class="line">.jScrollPane();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>详细见<a href="http://jscrollpane.kelvinluck.com/events.html" target="_blank" rel="noopener">官方文档</a></p><p>其他资源：<a href="http://www.jq22.com/" target="_blank" rel="noopener">jQuery插件库</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;日历插件&quot;&gt;&lt;a href=&quot;#日历插件&quot; class=&quot;headerlink&quot; title=&quot;日历插件&quot;&gt;&lt;/a&gt;日历插件&lt;/h2&gt;&lt;p&gt;1.&lt;a href=&quot;http://www.my97.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="jQuery" scheme="https://qiuyuxiu.github.io/MyBlog/categories/jQuery/"/>
    
    
      <category term="jQuery" scheme="https://qiuyuxiu.github.io/MyBlog/tags/jQuery/"/>
    
      <category term="插件" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用nvm管理node版本</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/01/08/%E4%BD%BF%E7%94%A8nvm%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/01/08/使用nvm管理node版本/</id>
    <published>2018-01-08T06:18:13.000Z</published>
    <updated>2018-06-09T15:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于在做项目的时候，遇到了node版本问题，于是使用nodist管理node版本，由使用版本4的转换到使用版本6，但是解析sass的时候出错了，提示说版本有误，可能是一些插件未随着版本的转换而转换。<br>因此现在我改用了nvm来管理node版本了。</p><p>下载安装nvm<br>下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><h2 id="卸载之前的node版本"><a href="#卸载之前的node版本" class="headerlink" title="卸载之前的node版本"></a>卸载之前的node版本</h2><p>如果之前是在官网下载的 node 安装包，运行后会自动安装在全局目录，其中node 命令在 /usr/local/bin/node ，npm 命令在全局 node_modules 目录中，具体路径为 /usr/local/lib/node_modules/npm<br>安装 nvm 之后最好先删除下已安装的 node 和全局 node 模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm ls -g --depth=0 #查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装</span><br><span class="line">sudo rm -rf /usr/local/lib/node_modules #删除全局 node_modules 目录</span><br><span class="line">sudo rm /usr/local/bin/node #删除 node</span><br><span class="line">cd  /usr/local/bin &amp;&amp; ls -l | grep &quot;../lib/node_modules/&quot; | awk &apos;&#123;print $9&#125;&apos;| xargs rm #删除全局 node 模块注册的软链</span><br></pre></td></tr></table></figure></p><p>注意：因为我之前是使用nodist管理的，所以卸载node，先将nodist卸载掉，之后将nodist的所有目录也删除掉。</p><h2 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h2><p><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash</code><br>安装完成后请重新打开终端环境，Mac 下推荐使用 oh-my-zsh 代替默认的 bash shell。</p><h2 id="安装切换各版本-node-npm"><a href="#安装切换各版本-node-npm" class="headerlink" title="安装切换各版本 node/npm"></a>安装切换各版本 node/npm</h2><p><code>nvm install stable</code> #安装最新稳定版 node，现在是 5.0.0<br><code>nvm install 4.2.2</code> #安装 4.2.2 版本<br><code>nvm install 0.12.7</code> #安装 0.12.7 版本<br><code>nvm use 0</code> #切换至 0.12.7 版本<br>//安装其他的依赖<br><code>npm install -g react-native-cli</code> #安装 <code>react-native-cli</code> 模块至全局目录</p><h2 id="查看当前的node版本"><a href="#查看当前的node版本" class="headerlink" title="查看当前的node版本"></a>查看当前的node版本</h2><p><code>nvm list</code></p><h2 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h2><p><code>nvm use &lt;version&gt; [arch]</code><br>文档见 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于在做项目的时候，遇到了node版本问题，于是使用nodist管理node版本，由使用版本4的转换到使用版本6，但是解析sass的时候出错了，提示说版本有误，可能是一些插件未随着版本的转换而转换。&lt;br&gt;因此现在我改用了nvm来管理node版本了。&lt;/p&gt;
&lt;p&gt;下载安装
      
    
    </summary>
    
      <category term="Node" scheme="https://qiuyuxiu.github.io/MyBlog/categories/Node/"/>
    
    
      <category term="nvm" scheme="https://qiuyuxiu.github.io/MyBlog/tags/nvm/"/>
    
      <category term="Node" scheme="https://qiuyuxiu.github.io/MyBlog/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>304状态码理解</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/12/08/304%E7%8A%B6%E6%80%81%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/12/08/304状态码理解/</id>
    <published>2017-12-08T11:19:16.000Z</published>
    <updated>2018-06-09T15:03:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>1、如果客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。<br>2、对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。<br>3、对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。</p><h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><p>1、在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记此文件在服务期端最后被修改的时间，格式类似这样：<br>Last-Modified: Fri, 12 May 2006 18:53:33 GMT</p><p>2、客户端第二次请求此URL时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否有被修改过：<br>If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT<br>服务器端的程序先取得这个字段的值，然后与服务器上的数据最后修改时间对比，如果服务器端的资源没有变化，就直接返回 304 Not Modified 状态码，然后停止。这样就节省了传输数据量，达到节省带宽的目的。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p><h2 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a>条件请求</h2><p>当用户访问一个网页时,条件请求可以加速网页的打开时间(因为可以省去传输整个响应体的时间),但仍然会有网络延迟,因为浏览器还是得为每个资源生成一条条件请求,并且等到服务器返回HTTP/304响应,才能读取缓存来显示网页.更理想的情况是,服务器在响应上指定Cache-Control或Expires指令,这样客户端就能知道该资源的可用时间为多长,也就能跳过条件请求的步骤,直接使用缓存中的资源了.<br>在下列情况下仍然需要使用条件请求<br>1)在超过服务器指定的过期时间之后<br>2)如果用户执行了刷新操作的话</p><h2 id="last-modified-if-modified-since"><a href="#last-modified-if-modified-since" class="headerlink" title="last-modified/if-modified-since"></a>last-modified/if-modified-since</h2><p>last-modified:表示这个响应资源的最后修改时间。<br>if-modified-since:当资源过期了(max-age)，发现资源有last-modified声明，则再次向服务器请求带上头部if-modified-since表示请求时间。<br>web服务器收到之后发现有头部if-modified-since，则与last-modified比较，如果last-modified比较新，则改动过，则响应整片内容；如果last-modified比较旧，则无修改，响应http304状态码，告诉浏览器继续使用所保存的cache。</p><p>除了使用ETag/If-None-Match/If-Match通过文件内容来缓存外，还可以使用Last-Modified/If-Modified-Since通过文件修改时间来进行缓存。 这两者都需要客户端再次发送HTTP请求，如果文件未发生改变，服务器返回304。<br>而另外一种缓存策略Expires/Cache-Control则可以让客户端避免再次发送请求。一般会优先使用Cache-Control，它能够更加精细地控制缓存策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;理解&quot;&gt;&lt;a href=&quot;#理解&quot; class=&quot;headerlink&quot; title=&quot;理解&quot;&gt;&lt;/a&gt;理解&lt;/h2&gt;&lt;p&gt;1、如果客户端在请求一个文件的时候，发现自己缓存的文件有 Last Modified ，那么在请求中会包含 If Modified Sinc
      
    
    </summary>
    
      <category term="状态码" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
    
      <category term="状态码" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>HTTP报文</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/11/08/HTTP%E6%8A%A5%E6%96%87/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/11/08/HTTP报文/</id>
    <published>2017-11-08T11:19:33.000Z</published>
    <updated>2018-06-09T15:01:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报文的组成部分"><a href="#报文的组成部分" class="headerlink" title="报文的组成部分"></a>报文的组成部分</h2><p>报文由三个部分组成：对报文进行描述的起始行，包含属性的首部块，以及可选的、包含数据的主体部分。<br><img src="../../../../images/pic4.png" alt="报文组成部分"><br>报文的语法:<br>所有的报文分为两类：请求报文，响应报文。</p><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成<br>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">//空行</span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p><p>1.请求行：请求方法，链接，HTTP版本。<br>GET<br>GET最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。<br>由于GET请求是在URL可见的，所以这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</p><p>POST<br>使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。<br>POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。POST方式大多用于页面的表单中。<br>2.请求头部：请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息。<br>3.空行<br>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。<br>4.请求数据<br>请求数据不在GET方法中使用，而是在POST方法中使用</p><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文<br>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;&lt;status-code&gt;&lt;reason-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">//空行</span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p><h2 id="报文各部分说明"><a href="#报文各部分说明" class="headerlink" title="报文各部分说明"></a>报文各部分说明</h2><p><code>&lt;method&gt;</code>: 客户端希望服务器对资源执行的动作，GET,POST…<br><code>&lt;request-URL&gt;</code>: 命名了所请求资源，或者URL路径组件的完整URL。<br><code>&lt;version&gt;</code>: 报文所使用的HTTP版本，HTTP/.<br><code>&lt;status-code&gt;</code>: 状态码<br><code>&lt;reason-phrase&gt;</code>: 状态码说明<br><code>&lt;header&gt;</code>: 首部<br><code>&lt;entity-body&gt;</code>: 实体的主体部分</p><h2 id="报文首部说明"><a href="#报文首部说明" class="headerlink" title="报文首部说明"></a>报文首部说明</h2><p>通用首部：既可以出现在请求报文中，也可以出现在响应报文中。<br>请求首部：提供更多的有关请求的信息。<br>响应首部：提供更多的有关响应的信息。<br>实体首部：描述主体的长度和内容，或者资源自身。<br>扩展首部：规范中没有定义的新首部。</p><h4 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h4><p>Connection,Date,MIME-Version,Trailer,Transfer-Encoding,Update,Via<br>通用缓存首部：Cache-Control,Pragma</p><h4 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h4><p>Accept首部:<br>Accept:text/html (告诉服务器能够发送哪些媒体类型)<br>Accept-Charset: (告诉服务器能够发送哪些字符集)<br>Accept-Encoding:gzip, deflate (告诉服务器能够发送哪些编码方式)<br>Accept-Language:zh-CN,zh;q=0.8 (告诉服务器能够发送哪些语言)</p><h4 id="条件请求首部："><a href="#条件请求首部：" class="headerlink" title="条件请求首部："></a>条件请求首部：</h4><p>Expect,If-Match,If-Modified-Since…</p><h4 id="安全请求首部："><a href="#安全请求首部：" class="headerlink" title="安全请求首部："></a>安全请求首部：</h4><p>Authorization,Cookie…</p><h4 id="代理请求首部："><a href="#代理请求首部：" class="headerlink" title="代理请求首部："></a>代理请求首部：</h4><p>Max-Forward,Proxy-Authorization,Proxy-Connection</p><h4 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h4><p>协商首部，安全响应首部</p><h4 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h4><p>内容首部，实体缓存首部</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;报文的组成部分&quot;&gt;&lt;a href=&quot;#报文的组成部分&quot; class=&quot;headerlink&quot; title=&quot;报文的组成部分&quot;&gt;&lt;/a&gt;报文的组成部分&lt;/h2&gt;&lt;p&gt;报文由三个部分组成：对报文进行描述的起始行，包含属性的首部块，以及可选的、包含数据的主体部分。&lt;br
      
    
    </summary>
    
      <category term="HTTP" scheme="https://qiuyuxiu.github.io/MyBlog/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://qiuyuxiu.github.io/MyBlog/tags/HTTP/"/>
    
      <category term="报文" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E6%8A%A5%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码与方法</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/08/08/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/08/08/HTTP状态码与方法/</id>
    <published>2017-08-08T08:21:20.000Z</published>
    <updated>2018-06-09T14:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了《HTTP权威指南》之后，整理些笔记。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><h4 id="100-199信息性状态码"><a href="#100-199信息性状态码" class="headerlink" title="100~199信息性状态码"></a>100~199信息性状态码</h4><p>100：continue 说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须响应。<br>101：Switching Protocols 说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议。</p><h4 id="200-299成功状态码"><a href="#200-299成功状态码" class="headerlink" title="200~299成功状态码"></a>200~299成功状态码</h4><p>200：OK 请求没问题，实体的主体部分包含了所请求的资源。<br>201：Create 用于创建服务器对象的请求（比如PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源的URL，location首部包含的则是最具体的引用。<br>202：Accepted 请求已被接受，但服务器还未对其执行任何动作，不能保证服务器会完成这个请求。</p><h4 id="300-399重定向状态码"><a href="#300-399重定向状态码" class="headerlink" title="300~399重定向状态码"></a>300~399重定向状态码</h4><p>300：Multiple Choices 客户端请求一个实际指向多个资源的URL时会返回这个状态码。<br>301 Moved Permanently 在请求的URL已被移除时使用，相应的location首部中应该包含资源现在所处的URL。<br>302 Found 与301状态码类似，但是，客户端应该使用location首部给出的URL来临时定位资源，将来的请求仍应使用老的URL。<br>303 see Other 告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部，其主要目的是允许post请求的响应将客户端定向到某个资源。<br>304 Not Modified 请求的资源未修改过。<br>307 Temporary 与301类似，但客户端应该使用location首部给出的URL来临时定位资源。</p><h4 id="400-499客户端错误状态码"><a href="#400-499客户端错误状态码" class="headerlink" title="400~499客户端错误状态码"></a>400~499客户端错误状态码</h4><p>400：Bad Request 用于告知客户端它发送了一个错误的请求<br>401：无权限<br>403:Forbidden 请求被服务器拒绝了。可查看实体的主体部分来知道为何。<br>404：Not Found 服务器无法找到所请求的资源</p><h4 id="500-599服务器错误状态码"><a href="#500-599服务器错误状态码" class="headerlink" title="500~599服务器错误状态码"></a>500~599服务器错误状态码</h4><p>500：Internal Server Error 服务器遇到一个妨碍它提供服务的错误<br>501：Not Implemented 客户端发起请求超出服务器的能力范围<br>502：Bad Gateway<br>503: Service Unavailable 说明服务器现在无法为请求提供服务，但将来可以</p><p>详细见W3school:<a href="http://www.w3school.com.cn/tags/html_ref_httpmessages.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/html_ref_httpmessages.asp</a></p><h2 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h2><h4 id="什么是-HTTP？"><a href="#什么是-HTTP？" class="headerlink" title="什么是 HTTP？"></a>什么是 HTTP？</h4><p>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。<br>HTTP 的工作方式是客户机与服务器之间的请求-应答协议。<br>web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。</p><h4 id="两种-HTTP-请求方法：GET-和-POST"><a href="#两种-HTTP-请求方法：GET-和-POST" class="headerlink" title="两种 HTTP 请求方法：GET 和 POST"></a>两种 HTTP 请求方法：GET 和 POST</h4><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。<br>GET - 从指定的资源请求数据。<br>POST - 向指定的资源提交要被处理的数据</p><h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h4><p>查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：<br>GET 请求可被缓存<br>GET 请求保留在浏览器历史记录中<br>GET 请求可被收藏为书签<br>GET 请求不应在处理敏感数据时使用<br>GET 请求有长度限制<br>GET 请求只应当用于取回数据</p><h4 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h4><p>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：<br>POST 请求不会被缓存<br>POST 请求不会保留在浏览器历史记录中<br>POST 不能被收藏为书签<br>POST 请求对数据长度没有要求</p><h4 id="其他请求方法："><a href="#其他请求方法：" class="headerlink" title="其他请求方法："></a>其他请求方法：</h4><p>HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。<br>PUT 上传指定的 URI 表示。<br>DELETE 删除指定资源。<br>OPTIONS 返回服务器支持的 HTTP 方法。<br>CONNECT 把请求连接转换到透明的 TCP/IP 通道</p><h2 id="GET-与-POST-区别："><a href="#GET-与-POST-区别：" class="headerlink" title="GET 与 POST 区别："></a>GET 与 POST 区别：</h2><p>GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。<br>GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 。<br>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。<br>GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。<br>GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。<br>GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。<br>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。<br>GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看了《HTTP权威指南》之后，整理些笔记。&lt;/p&gt;
&lt;h2 id=&quot;HTTP状态码&quot;&gt;&lt;a href=&quot;#HTTP状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP状态码&quot;&gt;&lt;/a&gt;HTTP状态码&lt;/h2&gt;&lt;h4 id=&quot;100-199信息性状态码&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="HTTP" scheme="https://qiuyuxiu.github.io/MyBlog/categories/HTTP/"/>
    
    
      <category term="状态码" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
      <category term="HTTP" scheme="https://qiuyuxiu.github.io/MyBlog/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/07/23/JavaScript%E4%BA%8B%E4%BB%B6/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/07/23/JavaScript事件/</id>
    <published>2017-07-23T02:22:05.000Z</published>
    <updated>2018-06-09T09:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h2><p>用于处理指定和删除事件处理程序的操作：addEventListener() 和removeEventListener()，接受三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。true表示捕获事件，false为冒泡事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;,false);</span><br><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(&quot;hello world!&quot;);</span><br><span class="line">&#125;,false);//btn hello world</span><br></pre></td></tr></table></figure></p><p>移除事件处理程序：removeEventListener()，传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">var handler=function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;;</span><br><span class="line">btn.addEventListener(&quot;click&quot;,handler,false);</span><br><span class="line">//移除</span><br><span class="line">btn.removeEventListener(&quot;click&quot;,handler,false);</span><br></pre></td></tr></table></figure></p><h2 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h2><p>attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。因为IE10及以下不支持捕获型事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;,function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;);</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;,function()&#123;</span><br><span class="line">    alert(&quot;hello world!&quot;);</span><br><span class="line">&#125;);//hello world  btn</span><br></pre></td></tr></table></figure></p><p>移除事件处理程序需要detachEvent()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">var handler=function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;;</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;,handler);</span><br><span class="line">//移除</span><br><span class="line">btn.detachEvent(&quot;onclick&quot;,handler);</span><br></pre></td></tr></table></figure></p><p>两者区别<br><code>addEventListener()</code> 是DOM2标准中定义的方法，它可以控制是在事件捕获阶段或者是在冒泡阶段调用事件处理程序（由这个函数的第三个参数决定true/false），既然这个是DOM2标准中定义的，那么只有支持DOM2级事件处理程序的浏览器才支持这个方法（IE9,Firefox,Safari,Chrome和Opera都支持这个）。<br><code>attachEvent()</code>方法并不是DOM标准定义的，而是IE自己实现的，而由于IE8及之前版本只支持事件冒泡，所以可想而知这个方法添加的事件处理程序都只能在冒泡阶段才会被调用，addEventListener()和attachEvent()还有一个区别就是第一个参数——事件类型，attachEvent()的事件类型都是前面带’on’的，比如点击事件 click ，addEventListener()可以传入 “click”，而 attachEvent() 却要传入 ‘onclick’；<br>在了解这些方法之前我都是直接使用DOM0事件处理程序的。然而是有一些缺陷的。它不支持一个元素多个事件处理程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    alert(&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    alert(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    alert(&quot;3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像这样子的程序，输出的结果只有3。而上面两种方法是支持多个事件处理程序，但是输出的结果顺序不一样。<br>由于浏览器支持的不同，因此需要跨浏览器的事件处理程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil=&#123;</span><br><span class="line">    addHandler:function(element,type,handler)&#123;</span><br><span class="line">        if(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:function(element,type,handler)&#123;</span><br><span class="line">        if(element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">var handler=function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;;</span><br><span class="line">EventUtil.addHandler(btn,&quot;click&quot;,handler);</span><br><span class="line">//移除</span><br><span class="line">EventUtil.removeHandler(btn,&quot;click&quot;,handler);</span><br></pre></td></tr></table></figure></p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>DOM中的事件对象：event对象。事件目标：event.target。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick=function(event)&#123;</span><br><span class="line">    alert(event.type);//click</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要阻止特定事件的默认行为，可以使用<code>preventDefault()</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var link=document.getElementById(&quot;myLink&quot;);</span><br><span class="line">link.onclick=function(event)&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>stopPropagation()方法用于停止事件在DOM层次中的传播，即取消进一步的事件捕获或者冒泡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick=function(event)&#123;</span><br><span class="line">    alert(&quot;Clicked&quot;);</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;;</span><br><span class="line">document.body.onclick=function(event)&#123;</span><br><span class="line">    alert(&quot;Body clicked&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>eventPhase属性可以用来确定事件当前正位于事件流的哪个阶段。</p><h2 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h2><p>事件目标：<code>event.srcElement</code><br>要阻止特定事件的默认行为，将<code>returnValue</code>设置为<code>false</code>即可。<br>阻止冒泡：将<code>cancelBubble</code>设置为<code>true</code>即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    var event=window.event;</span><br><span class="line">    alert(event.type);//click</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>跨浏览器的事件对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil=&#123;</span><br><span class="line">    addHandler:function(element,type,handler)&#123;</span><br><span class="line">        if(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getEvent:function(event)&#123;</span><br><span class="line">        return event?event:window.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget:function(event)&#123;</span><br><span class="line">        return event.target||event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault:function(event)&#123;</span><br><span class="line">        if(event.preventDefault)&#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            event.returnValue=false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:function(element,type,handler)&#123;</span><br><span class="line">        if(element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation:function(event)&#123;</span><br><span class="line">        if(event.stopPropagation)&#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            event.cancelBubble=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">EventUtil.addHandler(btn,&quot;click&quot;,function(event)&#123;</span><br><span class="line">    event=EventUtil.getEvent(event);</span><br><span class="line">    var target=EventUtil.getTarget(event);</span><br><span class="line">    alert(target);</span><br><span class="line">&#125;);</span><br><span class="line">var myLink=document.getElementById(&quot;myLink&quot;);</span><br><span class="line">EventUtil.addHandler(myLink,&quot;click&quot;,function(event)&#123;</span><br><span class="line">    event=EventUtil.getEvent(event);</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>一般是先判断事件再进行其他操作。</p><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>load事件：一般是window触发，还要图像也可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(window,&quot;load&quot;,function(event)&#123;</span><br><span class="line">    alert(&quot;loaded!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">var img=document.getElementById(&quot;myImg&quot;);</span><br><span class="line">EventUtil.addHandler(img,&quot;load&quot;,function(event)&#123;</span><br><span class="line">    event=EventUtil.getEvent(event);</span><br><span class="line">    alert(EventUtil.getTarget(event).src);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>unload事件：在文档被完全卸载后触发。<br>resize事件：当浏览器窗口被调整到一个新的高度或者宽度时就会触发resize事件。<br>scroll事件：页面中相应元素的变化。<br>blur事件：在元素失去焦点时触发。<br>focus事件：在元素获得焦点时触发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM2级事件处理程序&quot;&gt;&lt;a href=&quot;#DOM2级事件处理程序&quot; class=&quot;headerlink&quot; title=&quot;DOM2级事件处理程序&quot;&gt;&lt;/a&gt;DOM2级事件处理程序&lt;/h2&gt;&lt;p&gt;用于处理指定和删除事件处理程序的操作：addEventListene
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="JavaScript事件" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM2和DOM3</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/07/20/JavaScript-DOM2%E5%92%8CDOM3/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/07/20/JavaScript-DOM2和DOM3/</id>
    <published>2017-07-20T11:22:31.000Z</published>
    <updated>2018-06-09T09:32:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>样式：<br>访问元素的样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myDiv=document.getElementById(&apos;oDiv&apos;);</span><br><span class="line">myDiv.style.backgroundColor=&apos;red&apos;;</span><br></pre></td></tr></table></figure></p><p>当设置多个样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myDiv=document.getElementById(&apos;oDiv&apos;);</span><br><span class="line">myDiv.style.cssText=&quot;width: 200px;background-color: red;&quot;;</span><br></pre></td></tr></table></figure></p><p>另外还能通过getPropertyValue()和getPropertyCssValue()方法来访问css样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myDiv=document.getElementById(&apos;oDiv&apos;);</span><br><span class="line">var prop,value,i;</span><br><span class="line">var len=myDiv.style.length;</span><br><span class="line">for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">    prop=myDiv.style.item(i);</span><br><span class="line">    value=myDiv.style.getPropertyValue(prop);</span><br><span class="line">    alert(prop+&quot;:&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">var myDiv=document.getElementById(&apos;oDiv&apos;);</span><br><span class="line">var prop,value,i;</span><br><span class="line">var len=myDiv.style.length;</span><br><span class="line">for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">    prop=myDiv.style.item(i);</span><br><span class="line">    value=myDiv.style.getPropertyCSSValue(prop);</span><br><span class="line">    alert(prop+&quot;:&quot;+value.cssText+&quot;(&quot;+value.cssValueType+&quot;)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>移除样式：<code>removeProperty()</code>。</p><p>元素大小<br>偏移量：<br>offsetHeight：元素在垂直方向上占用的空间大小<br>offsetWidth：元素在水平方向上占用的空间大小<br>offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。<br>offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。<br>要知道某个元素在页面上的偏移量，将这个元素的offsetLeft 和offsetTop 与其offsetParent的相同属性相加，如此循环直至根元素，就能得到一个基本准确的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getElementLeft(element)&#123;</span><br><span class="line">    var actualLeft=element.offsetLeft;</span><br><span class="line">    var current=element.offsetParent;</span><br><span class="line">    while(current!==null)&#123;</span><br><span class="line">        actualLeft+=current.offsetLeft;</span><br><span class="line">        current=current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return actualLeft;</span><br><span class="line">&#125;</span><br><span class="line">function getElementTop(element)&#123;</span><br><span class="line">    var actualTop=element.offsetTop;</span><br><span class="line">    var current=element.offsetParent;</span><br><span class="line">    while(actualTop!==null)&#123;</span><br><span class="line">        actualTop+=current.offsetTop;</span><br><span class="line">        current=current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return actualTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户区大小：元素内容及其内边距所占据的空间大小。<br>clientWidth 和clientHeight。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getViewport()&#123;</span><br><span class="line">    if(document.compatMode==&quot;BackCompat&quot;)&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            width:document.body.clientWidth;</span><br><span class="line">            height:document.body.clientHeight;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            width:document.documentElement.clientWidth;</span><br><span class="line">            height:document.documentElement.clientHeight;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>滚动大小：包含滚动内容的元素的大小。<br>scrollTop：在被隐藏在内容区域上方的像素数。<br>scrollLeft：在被隐藏在内容区域左侧的像素数。<br>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。<br>srcollHeight：在没有滚动条的情况下，元素内容的总高度。<br>注意：在确定文档的总高度时（包括基于视口的最小高度时），必须取得scrollWidth/clientWidth和scrollHeight/clientHeight中的最大值，才能保证在跨浏览器的环境下得到精确的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getViewport(element)&#123;</span><br><span class="line">    var docHeight,docWidth;</span><br><span class="line">    if(document.compatMode==&quot;BackCompat&quot;)&#123;</span><br><span class="line">        docWidth=Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth);</span><br><span class="line">        docHeight=Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        docWidth=Math.max(document.body.scrollWidth,document.body.clientWidth);</span><br><span class="line">        docHeight=Math.max(document.body.scrollHeight,document.body.clientHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过改变scrollTop和scrollLeft的值来确定元素当前滚动的状态。<br>scrollTop=0：回到顶部</p><p>确定元素大小：getBoundingClientRect()方法。包含四个属性：top,left,right,bottom。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function getBoundingClientRect(element)&#123;</span><br><span class="line">    if(typeof arguments.callee.offset!=&quot;number&quot;)&#123;</span><br><span class="line">        var scrollTop=document.documentElement.scrollTop;</span><br><span class="line">        var temp=document.createElement(&quot;div&quot;);</span><br><span class="line">        temp.style.cssText=&quot;position: absolute;left:0;top:0;&quot;;</span><br><span class="line">        document.body.appendChild(temp);</span><br><span class="line">        arguments.callee.offset=-temp.getBoundingClientRect().top-scrollTop;</span><br><span class="line">        document.body.removeChild(temp);</span><br><span class="line">        temp=null;</span><br><span class="line">    &#125;</span><br><span class="line">    var rect=element.getBoundingClientRect();</span><br><span class="line">    var offset=arguments.callee.offset;</span><br><span class="line">    return&#123;</span><br><span class="line">        left:rect.left+offset,</span><br><span class="line">        right:rect.right+offset,</span><br><span class="line">        top:rect.top+offset,</span><br><span class="line">        bottom:rect.bottom+offset</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了跨浏览器实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function getElementLeft(element)&#123;</span><br><span class="line">    var actualLeft=element.offsetLeft;</span><br><span class="line">    var current=element.offsetParent;</span><br><span class="line">    while(current!==null)&#123;</span><br><span class="line">        actualLeft+=current.offsetLeft;</span><br><span class="line">        current=current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return actualLeft;</span><br><span class="line">&#125;</span><br><span class="line">function getElementTop(element)&#123;</span><br><span class="line">    var actualTop=element.offsetTop;</span><br><span class="line">    var current=element.offsetParent;</span><br><span class="line">    while(actualTop!==null)&#123;</span><br><span class="line">        actualTop+=current.offsetTop;</span><br><span class="line">        current=current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return actualTop;</span><br><span class="line">&#125;</span><br><span class="line">function getBoundingClientRect(element) &#123;</span><br><span class="line">    var scrollTop = document.documentElement.scrolltop;</span><br><span class="line">    var scrollLeft = document.documentElement.scrollleft;</span><br><span class="line">    if(element.getBoundingClientRect) &#123;</span><br><span class="line">        if(typeof arguments.callee.offset != &quot;number&quot;) &#123;</span><br><span class="line">            var scrollTop = document.documentElement.scrollTop;</span><br><span class="line">            var temp = document.createElement(&quot;div&quot;);</span><br><span class="line">            temp.style.cssText = &quot;position: absolute;left:0;top:0;&quot;;</span><br><span class="line">            document.body.appendChild(temp);</span><br><span class="line">            arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop;</span><br><span class="line">            document.body.removeChild(temp);</span><br><span class="line">            temp = null;</span><br><span class="line">        &#125;</span><br><span class="line">        var rect = element.getBoundingClientRect();</span><br><span class="line">        var offset = arguments.callee.offset;</span><br><span class="line">        return &#123;</span><br><span class="line">            left: rect.left + offset,</span><br><span class="line">            right: rect.right + offset,</span><br><span class="line">            top: rect.top + offset,</span><br><span class="line">            bottom: rect.bottom + offset</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        var actualLeft=getElementLeft(element);</span><br><span class="line">        var actualTop=getElementTop(element);</span><br><span class="line">        return&#123;</span><br><span class="line">            left:actualLeft-scrollLeft,</span><br><span class="line">            right:actualLeft+element.offsetWidth-screenLeft,</span><br><span class="line">            top:actualTop-scrollTop,</span><br><span class="line">            bottom:actualTop+element.offsetHeight-screenTop</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;样式：&lt;br&gt;访问元素的样式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://qiuyuxiu.github.io/MyBlog/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM扩展</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/07/18/JavaScript-DOM%E6%89%A9%E5%B1%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/07/18/JavaScript-DOM扩展/</id>
    <published>2017-07-18T06:22:44.000Z</published>
    <updated>2018-06-09T09:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h2><p>querySelector()接收一个css选择符，返回与该模式匹配的第一个元素。<br>querySelectorAll()接收的参数也是css选择符，返回的是一个NodeList的实例。通过item()和方括号来访问它的每个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var body=document.querySelector(&quot;body&quot;);</span><br><span class="line">var div=document.querySelector(&quot;#div&quot;);</span><br><span class="line">var className=document.querySelector(&quot;.btn&quot;);</span><br><span class="line">var img=document.querySelector(&quot;img.button&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="元素遍历：跨浏览器遍历某元素的所有子元素"><a href="#元素遍历：跨浏览器遍历某元素的所有子元素" class="headerlink" title="元素遍历：跨浏览器遍历某元素的所有子元素;"></a>元素遍历：跨浏览器遍历某元素的所有子元素;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var i,len,child=element.firstChild;</span><br><span class="line">while(child!=element.lastChild)&#123;</span><br><span class="line">    if(child.nodeType==1)&#123;</span><br><span class="line">        processChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    child=child.nextSibling;</span><br><span class="line">&#125;</span><br><span class="line">var i,len,child=element.firstElementChild;</span><br><span class="line">while(child!=element.lastElementChild)&#123;</span><br><span class="line">    processChild(child);</span><br><span class="line">    child=child.nextElementSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML5<br>getElementByTagName()方法：接收一个参数，包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。<br>add(),contains(),remove(),toggle()方法都是之后类名进行操作。</p><p>焦点管理<br>focus()方法是元素获得了焦点。<br>hasFocus()方法用于确定文档是否获得了焦点。</p><p>插入标记<br>innerHTML属性：innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的HTML标记。并非所有元素都支持这个innerHTML属性，不支持innerHTML属性的有:<code>&lt;head&gt;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择符API&quot;&gt;&lt;a href=&quot;#选择符API&quot; class=&quot;headerlink&quot; title=&quot;选择符API&quot;&gt;&lt;/a&gt;选择符API&lt;/h2&gt;&lt;p&gt;querySelector()接收一个css选择符，返回与该模式匹配的第一个元素。&lt;br&gt;querySele
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/28/JavaScript-DOM/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/28/JavaScript-DOM/</id>
    <published>2017-06-28T07:22:49.000Z</published>
    <updated>2018-06-09T07:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p>1.nodeType属性：为了确保跨浏览器兼容，最好要将这个属性与数字值进行比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(someNode.nodeType==1)&#123;</span><br><span class="line">    alert(&quot;Node is an element!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.nodeName和nodeValue属性：<br>最好先判断是不是一个元素，再来取得并保存nodeName的值。nodeName中保存的始终是元素的标签名。</p><p>3.childNodes属性：有着NodeList对象，是一种类数组对象。子节点可以用方括号和item()方法来访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var firstChild=someNode.childNodes[0];</span><br><span class="line">var secondChild=someNode.childNodes.item(1);</span><br><span class="line">var count=someNode.childNodes.length;</span><br></pre></td></tr></table></figure></p><p>要将NodeList转换为数组，必须手动枚举所有成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function convertToArray(nodes)&#123;</span><br><span class="line">    var array=null;</span><br><span class="line">    try&#123;</span><br><span class="line">        array=Array.prototype.slice.call(nodes,0);//针对非ie浏览器</span><br><span class="line">    &#125;catch(ex)&#123;</span><br><span class="line">        array=new Array();</span><br><span class="line">        for(var i=0,len=nodes.length;i&lt;len;i++)&#123;</span><br><span class="line">            array.push(nodes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>parentNode属性：父节点<br>previousSibling属性和nextSibling属性：访问同一列表中的其他节点。同胞节点。<br>firstChild和lastChild属性：第一个节点和最后一个节点。<br>hasChildNodes()属性：在节点包含一或多个子节点的情况下返回true。</p><p>操作节点：<br>appendChild()方法：用于向childNodes列表的末尾添加一个节点。<br>insertBefore()方法：接受两个参数：要插入的节点和作为参照的节点。如果参照节点为null，则insertBefore()与appendChild()执行相同的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//插入后成为最后一个子节点</span><br><span class="line">returnedNode=someNode.insertBefore(newNode,null);</span><br><span class="line">alert(newValue==someNode.lastChild);//true</span><br><span class="line">//插入后成为第一个子节点</span><br><span class="line">var returnedNode=someNode.insertBefore(newNode,someNode.firstChild);</span><br><span class="line">alert(returnedNode==newValue);//true</span><br><span class="line">alert(newValue==someNode.firstChild);//true</span><br><span class="line">//插入后成为最后一个子节点之前</span><br><span class="line">returnedNode=someNode.insertBefore(newNode,someNode.lastChild);</span><br><span class="line">alert(newValue==someNode.childNodes[someNode.childNodes.length-2]);//true</span><br><span class="line">replaceChild() 方法：接受两个参数：要插入的节点和要替换的节点。</span><br><span class="line"></span><br><span class="line">//替换第一个节点</span><br><span class="line">var returnedNode=someNode.replaceChild(newNode,someNode.firstChild);</span><br><span class="line">//替换最后一个节点</span><br><span class="line">returnedNode=someNode.replaceChild(newNode,someNode.lastChild);</span><br><span class="line">removeChild()方法：接受一个参数：即要移除的节点。</span><br><span class="line"></span><br><span class="line">//移除第一个节点</span><br><span class="line">var returnedNode=someNode.removeChild(someNode.firstChild);</span><br><span class="line">//移除最后一个节点</span><br><span class="line">returnedNode=someNode.removeChild(someNode.lastChild);</span><br><span class="line">cloneNode()方法接受一个布尔值参数，用于创建调用这个方法的 节点的一个完全相同的副本。</span><br></pre></td></tr></table></figure></p><h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>documentElement属性始终指向HTML页面中的元素。<br>body属性直接指向元素。<br>所有浏览器都支持document.documentElement和document.body属性。<br>Document对象还有title属性，URL属性，domain属性和referrer属性。<br>查找元素：getElementById() 和getElementsByTagName()，前者接受元素的id，后者接受元素的标签名。<br>getElementsByName() 这个方法返回带有给定name特性的所有元素。</p><h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>在HTML中，标签名始终都以全部大写表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(element.tagName.toLowerCase()==&quot;div&quot;)&#123;</span><br><span class="line">    //在此执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>取得特性：<br>getAttribute()：获取相应的特性值。getAttribute(“id”);<br>setAttribute()：设置相应的特性值。setAttribute(“id”,”oDiv”);<br>removeAttribute()：移除相应的特性值。removeAttribute(“id”);<br>attributes属性：element.attributes.getNameItem()；element.attributes[“ “]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementsByTagName(&quot;button&quot;)[0];</span><br><span class="line">var id=btn.attributes.getNamedItem(&quot;id&quot;).nodeValue;</span><br><span class="line">alert(id);</span><br></pre></td></tr></table></figure></p><p>一般来说，这个属性的方法不太方便，一般都是选用getAttribute()、setAttribute()、removeAttribute()。<br>不过在遍历元素的特性时可以用上attributes属性的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function outputAttributes(element)&#123;</span><br><span class="line">    var pairs=new Array(),</span><br><span class="line">        attrName,</span><br><span class="line">        attrValue,</span><br><span class="line">        i,</span><br><span class="line">        len;</span><br><span class="line">    for(i=0,len=element.attributes.length;i&lt;len;i++)&#123;</span><br><span class="line">        attrName=element.attributes[i].nodeName;</span><br><span class="line">        attrValue=element.attributes[i].nodeValue;</span><br><span class="line">        pairs.push(attrName+&quot;=\&quot;&quot;+attrValue+&quot;\&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   return pairs.join(&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">function outputAttributes(element)&#123;</span><br><span class="line">    var pairs=new Array(),</span><br><span class="line">        attrName,</span><br><span class="line">        attrValue,</span><br><span class="line">        i,</span><br><span class="line">        len;</span><br><span class="line">    for(i=0,len=element.attributes.length;i&lt;len;i++)&#123;</span><br><span class="line">        attrName=element.attributes[i].nodeName;</span><br><span class="line">        attrValue=element.attributes[i].nodeValue;</span><br><span class="line">        if(element.attributes[i].specified)&#123;</span><br><span class="line">            pairs.push(attrName+&quot;=\&quot;&quot;+attrValue+&quot;\&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   return pairs.join(&quot;  &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建元素：<br>document.createElement()方法可以创建新元素。接受一个参数：即要创建元素的标签名。<br>创建之后可以使用appendChild(),insertBefore(),replaceChild()方法进行添加到文档树中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var div=document.createElement(&quot;div&quot;);</span><br><span class="line">div.className=&quot;oDiv&quot;;</span><br><span class="line">div.id=&quot;oDiv&quot;;</span><br><span class="line">document.body.appendChild(div);</span><br></pre></td></tr></table></figure></p><h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>创建文本节点：document.createTextNode()，接受一个参数：要插入节点中的文本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var div=document.createElement(&quot;div&quot;);</span><br><span class="line">div.className=&quot;oDiv&quot;;</span><br><span class="line">div.id=&quot;oDiv&quot;;</span><br><span class="line">var textNode=document.createTextNode(&quot;hello world!&quot;);</span><br><span class="line">div.appendChild(textNode);</span><br><span class="line">document.body.appendChild(div);</span><br></pre></td></tr></table></figure></p><p>当多个文本节点的时候可以使用normalize()方法来规范化。<br>分割文本节点：splitText()，按照指定的位置进行分割文本节点的nodeValue值。</p><h2 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h2><p>有3个属性：name,value,specified<br>document.createAttribute()传入特性的名称可以创建新的特性节点。之后必须使用setAttributeNode()进行添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var attribute=document.createAttribute(&quot;align&quot;);</span><br><span class="line">attribute.value=&quot;left&quot;;</span><br><span class="line">element.setAttributeNode(attribute);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Node类型&quot;&gt;&lt;a href=&quot;#Node类型&quot; class=&quot;headerlink&quot; title=&quot;Node类型&quot;&gt;&lt;/a&gt;Node类型&lt;/h2&gt;&lt;p&gt;1.nodeType属性：为了确保跨浏览器兼容，最好要将这个属性与数字值进行比较：&lt;br&gt;&lt;figure c
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://qiuyuxiu.github.io/MyBlog/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript BOM</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/20/JavaScript-BOM/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/20/JavaScript-BOM/</id>
    <published>2017-06-20T11:22:55.000Z</published>
    <updated>2018-06-09T07:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>在全局作用域中声明的变量、函数都会变成window对象的属性和方法。全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var age=29;</span><br><span class="line">function sayAge()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">alert(window.age);//29</span><br><span class="line">sayAge();//29</span><br><span class="line">window.sayAge();//29</span><br></pre></td></tr></table></figure></p><p>在全局作用域中定义了age变量和sayAge()方法，他们都属于window对象的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var age=29;</span><br><span class="line">window.color=&quot;red&quot;;</span><br><span class="line">delete window.age;</span><br><span class="line">delete window.color;</span><br><span class="line">alert(window.age);//29</span><br><span class="line">alert(window.color);//undefined</span><br></pre></td></tr></table></figure></p><p>可见全局变量age不可以删除，在window对象上的属性color可以被删除掉。</p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><p>screenLeft 和 screenTop 属性：用来表示窗口相对于屏幕左边和上边的位置。<br>screenX 和 screenY 属性：提供相同的窗口位置信息。<br>但两者支持的浏览器不同。下面的代码可以跨浏览器取得窗口左边和上边的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var leftPos=(typeof window.screenLeft==&apos;number&apos;)?window.screenLeft:window.screenX;</span><br><span class="line">var topPos=(typeof window.screenTop==&apos;number&apos;)?window.screenTop:window.screenY;</span><br><span class="line">document.write(leftPos+&quot;  &quot;+topPos);</span><br></pre></td></tr></table></figure></p><p>全屏的情况下值为0 0。<br>moveTo()和moveBy() 是将窗口移动到一个新位置。<br>moveTo() 接受的是新位置的x和y坐标值，而moveBy() 接受的是在水平和垂直方向上移动的像素数。 但是现在很多浏览器已经禁用了。</p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>outerWidth和outerHeight返回浏览器窗口本身的尺寸；<br>innerWidth和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。<br>不同的浏览器支持的窗口大小的表示方式不同,因此也需要考虑浏览器兼容性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var pageWidth=window.innerWidth;</span><br><span class="line">var pageHeight=window.innerHeight;</span><br><span class="line">if(typeof pageWidth!=&apos;number&apos;)&#123;</span><br><span class="line">    if(document.compatMode==&quot;CSS1Compat&quot;)&#123;</span><br><span class="line">        pageWidth=document.documentElement.clientWidth;</span><br><span class="line">        pageHeight=document.documentElement.clientHeight;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        pageWidth=document.body.clientWidth;</span><br><span class="line">        pageHeight=document.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">document.write(pageWidth+&quot;   &quot;+pageHeight);</span><br></pre></td></tr></table></figure></p><p>resizeTo() 和 resizeBy() 方法可以调整浏览器窗口的大小。<br>resizeTo()接受的是窗口的新宽度和新高度，而resizeBy() 接受的是新窗口与原窗口的宽度和高度之差。不过现在有些浏览器也是禁用了的。</p><h4 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h4><p><code>window.open()</code> 方法可以接收四个参数：要加载的url，窗口目标，一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。第二个参数可以是：_self,_blank,_parent,_top。第三个参数可以是窗口的一些特性，例如width，height等等。<br><code>window.open(&quot; &quot;,&#39;myWin&#39;,&#39;width=200,height=200,top=100,left=50&#39;);</code><br><code>window.close()</code> 方法用来关闭窗口。<br>检验弹出窗口是否被屏蔽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bloked=false;</span><br><span class="line">try&#123;</span><br><span class="line">    var wroxWin=window.open(&quot;http://www.baidu.com&quot;,&apos;_blank&apos;);</span><br><span class="line">    if(wroxWin==null)&#123;</span><br><span class="line">        bloked=true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(ex)&#123;</span><br><span class="line">    bloked=true;</span><br><span class="line">&#125;</span><br><span class="line">if(bloked)&#123;</span><br><span class="line">    alert(&quot;The popup was bloked!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><p>setTimeout() 方法接受两个参数：要执行的代码和以毫秒表示的时间。<br>clearTimeout() 方法是取消超时调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var oBtn=document.getElementById(&apos;btn&apos;);</span><br><span class="line">var timeoutId=setTimeout(function()&#123;</span><br><span class="line">    alert(&quot;hello!&quot;);</span><br><span class="line">&#125;,1000);</span><br><span class="line">clearTimeout(timeoutId);</span><br></pre></td></tr></table></figure></p><p>设置间歇调用的方法是setInterval()。它接受的参数也是：要执行的代码和以毫秒表示的时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var num=0;</span><br><span class="line">var max=10;</span><br><span class="line">var intervalId=null;</span><br><span class="line">function incrementNumber()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    if(num==max)&#123;</span><br><span class="line">        clearInterval(intervalId);</span><br><span class="line">        alert(&quot;Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId=setInterval(incrementNumber,1000);</span><br><span class="line">var num=0;</span><br><span class="line">var max=10;</span><br><span class="line">function incrementNumber()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    if(num&lt;max)&#123;</span><br><span class="line">        setTimeout(incrementNumber,1000);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        alert(&quot;Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber,1000);</span><br></pre></td></tr></table></figure></p><p>这两种表达方式的效果都是一样的。不过最好不要使用间歇调用。</p><h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><p>alert(),confirm(),prompt()方法可以调用系统对话框向用户显示信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result=prompt(&quot;What is your name?&quot;);</span><br><span class="line">if(result)&#123;</span><br><span class="line">    alert(&quot;welcome,&quot;+result);//welcome,...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>查询字符串参数，在开发的时候经常用到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function getQueryStringArgs()&#123;</span><br><span class="line">  //取得查询字符串并去掉开头的问号</span><br><span class="line">  var qs=(location.search.length &gt;0?location.search.substring(1)：&apos;&apos;);</span><br><span class="line">  //保存数据的对象</span><br><span class="line">  arg=&#123;&#125;;</span><br><span class="line">  var items=qs.length?qs.split(&apos;&amp;&apos;):[],</span><br><span class="line">      item=null,</span><br><span class="line">      name=null,</span><br><span class="line">      //在for循环中使用</span><br><span class="line">      i=0,</span><br><span class="line">      len=items.length;</span><br><span class="line">  //逐个将每一项添加到args对象中</span><br><span class="line">  for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">     item=items[i].split(&quot;=&quot;);</span><br><span class="line">     name=decodeURIComponent(item[0]);</span><br><span class="line">     value=decodeURIComponent(item[1]);</span><br><span class="line">     if(name.length)&#123;</span><br><span class="line">        args[name]=value;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如：要查询的字符串是?q=javascript&amp;num=10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var args=getQueryStringArgs();</span><br><span class="line">alert(args[&quot;q&quot;]);//javascript</span><br><span class="line">alert(args[&quot;num&quot;]);//10</span><br></pre></td></tr></table></figure></p><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location.assign(&quot;http://www.baidu.com&quot;);</span><br><span class="line">window.location=&quot;http://www.baidu.com&quot;;</span><br><span class="line">location.href=&quot;http://www.baidu.com&quot;;</span><br><span class="line">这三种表达方式效果都是一样，打开百度的网页。</span><br><span class="line">另外修改location的hash,search,hostname,pathname,port属性可以改变当前加载的页面。</span><br><span class="line">假设初始的URL为http://www.baidu.com/win/</span><br><span class="line">//修改为：http://www.baidu.com/win/#section1</span><br><span class="line">location.hash = “#section1”;</span><br><span class="line">//修改为：http://www.baidu.com/win/?q=JavaScript</span><br><span class="line">location.search = “?q=javascript”;</span><br><span class="line">//修改为：http://www.yahoo.com/win/</span><br><span class="line">location.hostname = “www.yahoo.com”</span><br><span class="line">//修改为：http://www.baidu.com/win/mydir</span><br><span class="line">location.pathname = “mydir”</span><br><span class="line">//修改为：http://www.baidu.com:8080/win/</span><br><span class="line">location.port = “8080”</span><br></pre></td></tr></table></figure><p>replace()函数在设置URL方面与location的href属性或assign函数完全一样，但是它会删除history对象的地址列表中的URL，从而使Go或back等函数无法导航。<br>reload()函数是用于重新加载当前显示的页面。一般最好将reload() 放在代码的最后一行。</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history() 中使用最常的就是go()方法。<br>后退一页：history.go(-1)<br>前进一页：history.go(1)<br>前进两页：history.go(2)<br>也可以指定网页跳转：history.go(“url”),后退：history().back(),前进：history.forward()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;window对象&quot;&gt;&lt;a href=&quot;#window对象&quot; class=&quot;headerlink&quot; title=&quot;window对象&quot;&gt;&lt;/a&gt;window对象&lt;/h2&gt;&lt;p&gt;在全局作用域中声明的变量、函数都会变成window对象的属性和方法。全局变量不能通过dele
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="BOM" scheme="https://qiuyuxiu.github.io/MyBlog/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包问题</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript闭包问题/</id>
    <published>2017-06-17T05:23:11.000Z</published>
    <updated>2018-06-09T07:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数的闭包：有权访问另一个函数作用域中的变量的函数。常见方式：在一个函数内部创建另一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertuName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1=object1[propertuName];</span><br><span class="line">        var value2=object2[propertuName];</span><br><span class="line">        if(value1&lt;value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1&gt;value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createFunction()&#123;</span><br><span class="line">    var result=new Array();</span><br><span class="line">    for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">        result[i]=function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">var funcs = createFunction();</span><br><span class="line">for (var i=0; i &lt; funcs.length; i++)&#123;</span><br><span class="line">    document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>createFunction()函数返回一个数组。表面上看，似乎每个函数都应该返回自己的索引值，但事实并非如此，事实上每个函数的返回值都是10.因为每个函数的作用域链中都包含着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值就是10，此时每个函数都引用着保存变量i的同一个变量对象，所以每个函数返回后都是10。</p><p>创建另一个匿名函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createFunction() &#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function(num) &#123;</span><br><span class="line">            return function() &#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">var funcs = createFunction();</span><br><span class="line">for(var i = 0; i &lt; funcs.length; i++) &#123;</span><br><span class="line">    document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在重写了前面的createFunction()函数后，每个函数就会返回各自不同的索引值了。在这里，我们没有直接把闭包赋值给数值，而是定义了一个匿名函数，并将立即执行该函数的结果赋值给数组。这里的匿名函数有一个参数num,也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数参数按值传递的，所以就会将变量i的当前值复制给参数num。而在这个匿名函数内部，有创建并返回了一个访问num的闭包。这样依赖，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了。</p><p>闭包的作用：一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;　　　　</span><br><span class="line">    var n = 9;  　　　　</span><br><span class="line">    Add = function() &#123;</span><br><span class="line">        n += 1</span><br><span class="line">    &#125;   　　　　</span><br><span class="line">    function f2() &#123;　　　　　　</span><br><span class="line">        alert(n);　　　　</span><br><span class="line">    &#125;   　　　　</span><br><span class="line">    return f2;  　　</span><br><span class="line">&#125;　　</span><br><span class="line">var result = f1();　　</span><br><span class="line">result(); // 9　</span><br><span class="line">Add();　　</span><br><span class="line">result(); // 10</span><br></pre></td></tr></table></figure></p><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是9，第二次的值是10。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。一般将其设置为null可以删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function assignHandler()&#123;</span><br><span class="line">    var element=document.getElementById(&quot;someElement&quot;);</span><br><span class="line">    var id=element.id;</span><br><span class="line">    element.onclick=function()&#123;</span><br><span class="line">         alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    element=null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量的作用域<br>要理解闭包，首先必须理解Javascript特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量，在函数外部自然无法读取函数内的局部变量。</p><p>用闭包模拟私有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var Counter = (function() &#123;</span><br><span class="line">  var privateCounter = 0;</span><br><span class="line">  function changeBy(val) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    increment: function() &#123;</span><br><span class="line">      changeBy(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: function() &#123;</span><br><span class="line">      changeBy(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(Counter.value()); /* logs 0 */</span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line">console.log(Counter.value()); /* logs 2 */</span><br><span class="line">Counter.decrement();</span><br><span class="line">console.log(Counter.value()); /* logs 1 */</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数的闭包：有权访问另一个函数作用域中的变量的函数。常见方式：在一个函数内部创建另一个函数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="闭包" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Function类型</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-Function%E7%B1%BB%E5%9E%8B/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-Function类型/</id>
    <published>2017-06-17T03:43:27.000Z</published>
    <updated>2018-06-09T07:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为值的函数：不仅可以像传递参数一样传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction,someArgument)&#123;</span><br><span class="line">    return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line">function add10(num)&#123;</span><br><span class="line">    return num+10;</span><br><span class="line">&#125;</span><br><span class="line">var result=callSomeFunction(add10,10);</span><br><span class="line">document.write(result);//20</span><br><span class="line">function getGreeting(name)&#123;</span><br><span class="line">    return &quot;hello, &quot;+name;</span><br><span class="line">&#125;</span><br><span class="line">var result2=callSomeFunction(getGreeting,&quot;Nike&quot;);</span><br><span class="line">document.write(result2);//hello, Nike</span><br></pre></td></tr></table></figure></p><p>sort()方法用到这种从一个函数返回另一个函数的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertuName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1=object1[propertuName];</span><br><span class="line">        var value2=object2[propertuName];</span><br><span class="line">        if(value1&lt;value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1&gt;value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var data=[&#123;name:&quot;Zachary&quot;,age:28&#125;,&#123;name:&quot;Nick&quot;,age:29&#125;];</span><br><span class="line">data.sort(createComparisonFunction(&quot;name&quot;));</span><br><span class="line">document.write(data[0].name);//Nick</span><br><span class="line">data.sort(createComparisonFunction(&quot;age&quot;));</span><br><span class="line">document.write(data[0].name);//Zachary</span><br></pre></td></tr></table></figure></p><p>函数内部属性：arguments 和 this<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num*factorial(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result=factorial(9);</span><br><span class="line">alert(result);</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num*arguments.callee(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result=factorial(9);</span><br><span class="line">alert(result);</span><br></pre></td></tr></table></figure></p><p>这两个函数执行的结果一样，都为362880。<br>函数属性和方法：<br>每个函数都包含两个属性：length和prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayName(name)&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">&#125;</span><br><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">    alert(&quot;hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">alert(sayName.length);//1</span><br><span class="line">alert(sum.length);//2</span><br><span class="line">alert(sayHi.length);//0</span><br></pre></td></tr></table></figure></p><p>每个函数包含两个非继承而来的方法apply()和call()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">function callSum2(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,[num1,num2]);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(10,10));//20</span><br><span class="line">alert(callSum2(10,10));//20</span><br></pre></td></tr></table></figure></p><p>call() 方法第二个参数是其余参数直接传递给函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1,num2)&#123;</span><br><span class="line">    return sum.call(this,num1,num2);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(10,10));//20</span><br></pre></td></tr></table></figure></p><p>在讨论javascript的继承中也用到了call()方法。</p><p>bind() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.color=&quot;red&quot;;</span><br><span class="line">var o=&#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor=sayColor.bind(o);</span><br><span class="line">objectSayColor();//blue</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为值的函数：不仅可以像传递参数一样传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="Function类型" scheme="https://qiuyuxiu.github.io/MyBlog/tags/Function%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 继承</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-%E7%BB%A7%E6%89%BF/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-继承/</id>
    <published>2017-06-17T02:27:36.000Z</published>
    <updated>2018-06-09T07:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property=true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty=false;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype=new SuperType();//继承SuperType</span><br><span class="line">SubType.prototype.getSubValue=function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.getSubValue());//false</span><br><span class="line">alert(instance.getSuperValue());//true</span><br></pre></td></tr></table></figure></p><p>注意：子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property=true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty=false;</span><br><span class="line">&#125;</span><br><span class="line">//继承SuperType</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">//添加新方法</span><br><span class="line">SubType.prototype.getSubValue=function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">//重写超类型中的方法</span><br><span class="line">SubType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.getSubValue());//false</span><br><span class="line">alert(instance.getSuperValue());//false</span><br><span class="line">不能使用对象字面量创建原型方法。</span><br></pre></td></tr></table></figure></p><p>原型链的问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">&#125;</span><br><span class="line">//继承</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">var instance=new SubType();</span><br><span class="line">instance.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance.colors);//red,blue,green,black</span><br><span class="line">var instance2=new SubType();</span><br><span class="line">alert(instance2.colors);//red,blue,green,black</span><br></pre></td></tr></table></figure></p><p>这个问题和在创建对象的时候也有，因为colors是共享属性。</p><p>借用构造函数：使用apply() 和call() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    //继承</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">instance.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance.colors);//red,blue,green,black</span><br><span class="line">var instance2=new SubType();</span><br><span class="line">alert(instance2.colors);//red,blue,green</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    //继承</span><br><span class="line">    SuperType.call(this,&quot;Nick&quot;);</span><br><span class="line">    this.age=29;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.name);//Nick</span><br><span class="line">alert(instance.age);//29</span><br></pre></td></tr></table></figure></p><p>组合继承：将原型链和借用构造函数的技术组合到一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    thia.name=name;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName=function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">//继承方法</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line">SubType.prototype.sayAge=function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var instance1=new SubType(&quot;Nick&quot;,29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);//red,blue,green,black</span><br><span class="line">instance1.sayName();//Nick</span><br><span class="line">instance1.sayAge();//29</span><br><span class="line">var instance2=new SubType(&quot;Greg&quot;,27);</span><br><span class="line">alert(instance1.colors);//red,blue,green</span><br><span class="line">instance1.sayName();//Greg</span><br><span class="line">instance1.sayAge();//27</span><br></pre></td></tr></table></figure></p><p>还有其他的一些继承方式比较少见的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="继承" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面向对象</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-面向对象/</id>
    <published>2017-06-17T01:23:49.000Z</published>
    <updated>2018-06-09T07:09:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>要修改对象的属性的默认的特性，必须使用Object.defineProperty() 方法。这个方法接受三个参数：属性所在的对象，属性的名字，一个描述符对象。描述符对象的属性必须是configurable,enumberable,writable,value。在不指定情况下，configurable,enumberable,writable这三个属性都是默认为false。<br>configurable设置为false 表示不能从对象中删除属性。writable设置为false表示是只读的，不能对属性进行赋值。enumberable表示能否通过for-in循环返回属性。</p><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>在读取访问器属性时，会调用getter函数；在写入访问器属性时，会调用setter函数并传入新值。<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;</span><br><span class="line">    _year:2004,</span><br><span class="line">    edition:1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function(newValue)&#123;</span><br><span class="line">        if(newValue&gt;2004)&#123;</span><br><span class="line">            this._year=newValue;</span><br><span class="line">            this.edition+=newValue-2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year=2005;</span><br><span class="line">alert(book.edition);//2</span><br></pre></td></tr></table></figure></p><p>定义多个属性：Object.defineProperties()方法。<br>读取属性的特征：Object.getOwnPropertyDescriptor()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        value:2004,</span><br><span class="line">        writable: true//这个必须写，不然不能下面book.year没有启用而起作用弹出2007，不然就弹出2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        value:1</span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        get:function()&#123;</span><br><span class="line">            return this._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function(newValue)&#123;</span><br><span class="line">            if(newValue&gt;2004)&#123;</span><br><span class="line">                this._year=newValue;</span><br><span class="line">                this.edition+=newValue-2004;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var descriptor=Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);</span><br><span class="line">alert(descriptor.value);//2004</span><br><span class="line">alert(descriptor.configurable);//false</span><br><span class="line">book.year=2007;</span><br><span class="line">alert(book._year);//2007</span><br></pre></td></tr></table></figure></p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>1.工厂模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o=new Object();</span><br><span class="line">    o.name=name;</span><br><span class="line">    o.age=age;</span><br><span class="line">    o.job=job;</span><br><span class="line">    o.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1=createPerson(&quot;Nick&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.sayName();//Nick</span><br><span class="line">alert(person2.name);//Greg</span><br></pre></td></tr></table></figure></p><p>2.构造函数模式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.job=job;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1=new Person(&quot;Nick&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.sayName();//Nick</span><br><span class="line">alert(person2.name);//Greg</span><br></pre></td></tr></table></figure></p><p>3.原型模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=&quot;Nike&quot;;</span><br><span class="line">Person.prototype.age=29;</span><br><span class="line">Person.prototype.job=&quot;Engineer&quot;;</span><br><span class="line">Person.prototype.sayName=function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">person1.sayName();//Nike</span><br><span class="line">var person2=new Person();</span><br><span class="line">person2.sayName();//Nike</span><br><span class="line">alert(person1.sayName==person2.sayName);//true</span><br><span class="line">hasOwnProperty() 方法可以检测一个属性是否存在于实例中，还是存在于原型中。如果存在于对象实例中，则返回true。</span><br><span class="line">hasPrototypeProperty() 方法可以检测一个属性是否存在于实例中，还是存在于原型中。如果存在于对象原型中，则返回true。</span><br><span class="line">Object.keys() 方法接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</span><br></pre></td></tr></table></figure></p><p>更简单的原型语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  name: &quot;Nike&quot;,</span><br><span class="line">  age: 29,</span><br><span class="line">  job: &quot;Engineer&quot;,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>原型对象的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &quot;Nike&quot;,</span><br><span class="line">  job: &quot;Engineer&quot;,</span><br><span class="line">  friends: [&quot;Shelby&quot;,&quot;Court&quot;],</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">var person2=new Person();</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);//Shelby,Court,Van</span><br><span class="line">alert(person2.friends);//Shelby,Court,Van</span><br><span class="line">alert(person1.friends==person2.friends);//true</span><br></pre></td></tr></table></figure></p><p>可以看到当改变一个对象的friends时，其他的对象的friends也跟着改变friends数组存在于person.prototype中，而不是存在于person1中，所以当改变person1的friends时候，person2的friends也变化。</p><p>4.组合使用构造函数模式和原型模式：构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">  this.job=job;</span><br><span class="line">  this.friends=[&quot;Shelby&quot;,&quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1=new Person(&quot;Nike&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);//Shelby,Court,Van</span><br><span class="line">alert(person2.friends);//Shelby,Court</span><br><span class="line">alert(person1.friends==person2.friends);//false</span><br><span class="line">alert(person1.sayName==person2.sayName);//true</span><br></pre></td></tr></table></figure></p><p>5.动态原型模式<br>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;) &#123; //在sayName()方法不存在的情况下，才会将它添加到原型中。instanceof操作符也可以</span><br><span class="line">        Person.prototype.sayName = function() &#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person(&quot;Nike&quot;, 29, &quot;Engineer&quot;);</span><br><span class="line">friend.sayName();//Nike</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h2&gt;&lt;p&gt;要修改对象的属性的默认的特性，必须使用Object.defineProperty() 方法。这个方法接受三个参数：属性所在的
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
