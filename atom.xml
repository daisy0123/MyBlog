<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>有关于前端学习的个人博客</subtitle>
  <link href="/MyBlog/atom.xml" rel="self"/>
  
  <link href="https://qiuyuxiu.github.io/MyBlog/"/>
  <updated>2018-06-08T11:19:33.604Z</updated>
  <id>https://qiuyuxiu.github.io/MyBlog/</id>
  
  <author>
    <name>Daisy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP报文</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/HTTP%E6%8A%A5%E6%96%87/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/HTTP报文/</id>
    <published>2018-06-08T11:19:33.000Z</published>
    <updated>2018-06-08T11:19:33.604Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>304状态码理解</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/304%E7%8A%B6%E6%80%81%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/304状态码理解/</id>
    <published>2018-06-08T11:19:16.000Z</published>
    <updated>2018-06-08T11:19:16.240Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用nvm管理node版本</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E4%BD%BF%E7%94%A8nvm%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/使用nvm管理node版本/</id>
    <published>2018-06-08T11:18:13.000Z</published>
    <updated>2018-06-08T11:18:13.485Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jQuery多种插件使用说明</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/jQuery%E5%A4%9A%E7%A7%8D%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/jQuery多种插件使用说明/</id>
    <published>2018-06-08T11:17:55.000Z</published>
    <updated>2018-06-08T11:17:55.538Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>html知识点</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/html%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/html知识点/</id>
    <published>2018-06-08T11:17:33.000Z</published>
    <updated>2018-06-08T11:17:33.349Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存泄漏问题</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/内存泄漏问题/</id>
    <published>2018-06-08T08:53:07.000Z</published>
    <updated>2018-06-08T08:53:07.783Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手写promise</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E6%89%8B%E5%86%99promise/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/手写promise/</id>
    <published>2018-06-08T08:52:57.000Z</published>
    <updated>2018-06-08T08:52:58.018Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSONP</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/JSONP/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/JSONP/</id>
    <published>2018-06-08T08:52:46.000Z</published>
    <updated>2018-06-08T08:52:46.608Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http三个版本</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/http%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/http三个版本/</id>
    <published>2018-06-08T08:52:34.000Z</published>
    <updated>2018-06-08T08:52:34.088Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>长连接&amp;短连接&amp;长轮询&amp;短轮询</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2018/06/08/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5-%E9%95%BF%E8%BD%AE%E8%AF%A2-%E7%9F%AD%E8%BD%AE%E8%AF%A2/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2018/06/08/长连接-短连接-长轮询-短轮询/</id>
    <published>2018-06-08T08:52:19.000Z</published>
    <updated>2018-06-08T08:52:19.904Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP状态码与方法</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/08/08/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/08/08/HTTP状态码与方法/</id>
    <published>2017-08-08T08:21:20.000Z</published>
    <updated>2018-06-09T14:45:04.118Z</updated>
    
    <content type="html"><![CDATA[<p>看了《HTTP权威指南》之后，整理些笔记。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><h4 id="100-199信息性状态码"><a href="#100-199信息性状态码" class="headerlink" title="100~199信息性状态码"></a>100~199信息性状态码</h4><p>100：continue 说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须响应。<br>101：Switching Protocols 说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议。</p><h4 id="200-299成功状态码"><a href="#200-299成功状态码" class="headerlink" title="200~299成功状态码"></a>200~299成功状态码</h4><p>200：OK 请求没问题，实体的主体部分包含了所请求的资源。<br>201：Create 用于创建服务器对象的请求（比如PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源的URL，location首部包含的则是最具体的引用。<br>202：Accepted 请求已被接受，但服务器还未对其执行任何动作，不能保证服务器会完成这个请求。</p><h4 id="300-399重定向状态码"><a href="#300-399重定向状态码" class="headerlink" title="300~399重定向状态码"></a>300~399重定向状态码</h4><p>300：Multiple Choices 客户端请求一个实际指向多个资源的URL时会返回这个状态码。<br>301 Moved Permanently 在请求的URL已被移除时使用，相应的location首部中应该包含资源现在所处的URL。<br>302 Found 与301状态码类似，但是，客户端应该使用location首部给出的URL来临时定位资源，将来的请求仍应使用老的URL。<br>303 see Other 告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的location首部，其主要目的是允许post请求的响应将客户端定向到某个资源。<br>304 Not Modified 请求的资源未修改过。<br>307 Temporary 与301类似，但客户端应该使用location首部给出的URL来临时定位资源。</p><h4 id="400-499客户端错误状态码"><a href="#400-499客户端错误状态码" class="headerlink" title="400~499客户端错误状态码"></a>400~499客户端错误状态码</h4><p>400：Bad Request 用于告知客户端它发送了一个错误的请求<br>401：无权限<br>403:Forbidden 请求被服务器拒绝了。可查看实体的主体部分来知道为何。<br>404：Not Found 服务器无法找到所请求的资源</p><h4 id="500-599服务器错误状态码"><a href="#500-599服务器错误状态码" class="headerlink" title="500~599服务器错误状态码"></a>500~599服务器错误状态码</h4><p>500：Internal Server Error 服务器遇到一个妨碍它提供服务的错误<br>501：Not Implemented 客户端发起请求超出服务器的能力范围<br>502：Bad Gateway<br>503: Service Unavailable 说明服务器现在无法为请求提供服务，但将来可以</p><p>详细见W3school:<a href="http://www.w3school.com.cn/tags/html_ref_httpmessages.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/html_ref_httpmessages.asp</a></p><h2 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h2><h4 id="什么是-HTTP？"><a href="#什么是-HTTP？" class="headerlink" title="什么是 HTTP？"></a>什么是 HTTP？</h4><p>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。<br>HTTP 的工作方式是客户机与服务器之间的请求-应答协议。<br>web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。</p><h4 id="两种-HTTP-请求方法：GET-和-POST"><a href="#两种-HTTP-请求方法：GET-和-POST" class="headerlink" title="两种 HTTP 请求方法：GET 和 POST"></a>两种 HTTP 请求方法：GET 和 POST</h4><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。<br>GET - 从指定的资源请求数据。<br>POST - 向指定的资源提交要被处理的数据</p><h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h4><p>查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：<br>GET 请求可被缓存<br>GET 请求保留在浏览器历史记录中<br>GET 请求可被收藏为书签<br>GET 请求不应在处理敏感数据时使用<br>GET 请求有长度限制<br>GET 请求只应当用于取回数据</p><h4 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h4><p>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：<br>POST 请求不会被缓存<br>POST 请求不会保留在浏览器历史记录中<br>POST 不能被收藏为书签<br>POST 请求对数据长度没有要求</p><h4 id="其他请求方法："><a href="#其他请求方法：" class="headerlink" title="其他请求方法："></a>其他请求方法：</h4><p>HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。<br>PUT 上传指定的 URI 表示。<br>DELETE 删除指定资源。<br>OPTIONS 返回服务器支持的 HTTP 方法。<br>CONNECT 把请求连接转换到透明的 TCP/IP 通道</p><h2 id="GET-与-POST-区别："><a href="#GET-与-POST-区别：" class="headerlink" title="GET 与 POST 区别："></a>GET 与 POST 区别：</h2><p>GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。<br>GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 。<br>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。<br>GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。<br>GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。<br>GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。<br>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。<br>GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看了《HTTP权威指南》之后，整理些笔记。&lt;/p&gt;
&lt;h2 id=&quot;HTTP状态码&quot;&gt;&lt;a href=&quot;#HTTP状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP状态码&quot;&gt;&lt;/a&gt;HTTP状态码&lt;/h2&gt;&lt;h4 id=&quot;100-199信息性状态码&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="HTTP" scheme="https://qiuyuxiu.github.io/MyBlog/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://qiuyuxiu.github.io/MyBlog/tags/HTTP/"/>
    
      <category term="状态码" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/07/23/JavaScript%E4%BA%8B%E4%BB%B6/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/07/23/JavaScript事件/</id>
    <published>2017-07-23T02:22:05.000Z</published>
    <updated>2018-06-09T09:39:12.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h2><p>用于处理指定和删除事件处理程序的操作：addEventListener() 和removeEventListener()，接受三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。true表示捕获事件，false为冒泡事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;,false);</span><br><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(&quot;hello world!&quot;);</span><br><span class="line">&#125;,false);//btn hello world</span><br></pre></td></tr></table></figure></p><p>移除事件处理程序：removeEventListener()，传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">var handler=function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;;</span><br><span class="line">btn.addEventListener(&quot;click&quot;,handler,false);</span><br><span class="line">//移除</span><br><span class="line">btn.removeEventListener(&quot;click&quot;,handler,false);</span><br></pre></td></tr></table></figure></p><h2 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h2><p>attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。因为IE10及以下不支持捕获型事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;,function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;);</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;,function()&#123;</span><br><span class="line">    alert(&quot;hello world!&quot;);</span><br><span class="line">&#125;);//hello world  btn</span><br></pre></td></tr></table></figure></p><p>移除事件处理程序需要detachEvent()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">var handler=function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;;</span><br><span class="line">btn.attachEvent(&quot;onclick&quot;,handler);</span><br><span class="line">//移除</span><br><span class="line">btn.detachEvent(&quot;onclick&quot;,handler);</span><br></pre></td></tr></table></figure></p><p>两者区别<br><code>addEventListener()</code> 是DOM2标准中定义的方法，它可以控制是在事件捕获阶段或者是在冒泡阶段调用事件处理程序（由这个函数的第三个参数决定true/false），既然这个是DOM2标准中定义的，那么只有支持DOM2级事件处理程序的浏览器才支持这个方法（IE9,Firefox,Safari,Chrome和Opera都支持这个）。<br><code>attachEvent()</code>方法并不是DOM标准定义的，而是IE自己实现的，而由于IE8及之前版本只支持事件冒泡，所以可想而知这个方法添加的事件处理程序都只能在冒泡阶段才会被调用，addEventListener()和attachEvent()还有一个区别就是第一个参数——事件类型，attachEvent()的事件类型都是前面带’on’的，比如点击事件 click ，addEventListener()可以传入 “click”，而 attachEvent() 却要传入 ‘onclick’；<br>在了解这些方法之前我都是直接使用DOM0事件处理程序的。然而是有一些缺陷的。它不支持一个元素多个事件处理程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    alert(&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    alert(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    alert(&quot;3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像这样子的程序，输出的结果只有3。而上面两种方法是支持多个事件处理程序，但是输出的结果顺序不一样。<br>由于浏览器支持的不同，因此需要跨浏览器的事件处理程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil=&#123;</span><br><span class="line">    addHandler:function(element,type,handler)&#123;</span><br><span class="line">        if(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:function(element,type,handler)&#123;</span><br><span class="line">        if(element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">var handler=function()&#123;</span><br><span class="line">    alert(this.id);</span><br><span class="line">&#125;;</span><br><span class="line">EventUtil.addHandler(btn,&quot;click&quot;,handler);</span><br><span class="line">//移除</span><br><span class="line">EventUtil.removeHandler(btn,&quot;click&quot;,handler);</span><br></pre></td></tr></table></figure></p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>DOM中的事件对象：event对象。事件目标：event.target。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick=function(event)&#123;</span><br><span class="line">    alert(event.type);//click</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要阻止特定事件的默认行为，可以使用<code>preventDefault()</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var link=document.getElementById(&quot;myLink&quot;);</span><br><span class="line">link.onclick=function(event)&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>stopPropagation()方法用于停止事件在DOM层次中的传播，即取消进一步的事件捕获或者冒泡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick=function(event)&#123;</span><br><span class="line">    alert(&quot;Clicked&quot;);</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;;</span><br><span class="line">document.body.onclick=function(event)&#123;</span><br><span class="line">    alert(&quot;Body clicked&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>eventPhase属性可以用来确定事件当前正位于事件流的哪个阶段。</p><h2 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h2><p>事件目标：<code>event.srcElement</code><br>要阻止特定事件的默认行为，将<code>returnValue</code>设置为<code>false</code>即可。<br>阻止冒泡：将<code>cancelBubble</code>设置为<code>true</code>即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    var event=window.event;</span><br><span class="line">    alert(event.type);//click</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>跨浏览器的事件对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil=&#123;</span><br><span class="line">    addHandler:function(element,type,handler)&#123;</span><br><span class="line">        if(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getEvent:function(event)&#123;</span><br><span class="line">        return event?event:window.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget:function(event)&#123;</span><br><span class="line">        return event.target||event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault:function(event)&#123;</span><br><span class="line">        if(event.preventDefault)&#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            event.returnValue=false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:function(element,type,handler)&#123;</span><br><span class="line">        if(element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot;+type,handler);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation:function(event)&#123;</span><br><span class="line">        if(event.stopPropagation)&#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            event.cancelBubble=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">EventUtil.addHandler(btn,&quot;click&quot;,function(event)&#123;</span><br><span class="line">    event=EventUtil.getEvent(event);</span><br><span class="line">    var target=EventUtil.getTarget(event);</span><br><span class="line">    alert(target);</span><br><span class="line">&#125;);</span><br><span class="line">var myLink=document.getElementById(&quot;myLink&quot;);</span><br><span class="line">EventUtil.addHandler(myLink,&quot;click&quot;,function(event)&#123;</span><br><span class="line">    event=EventUtil.getEvent(event);</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>一般是先判断事件再进行其他操作。</p><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>load事件：一般是window触发，还要图像也可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(window,&quot;load&quot;,function(event)&#123;</span><br><span class="line">    alert(&quot;loaded!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">var img=document.getElementById(&quot;myImg&quot;);</span><br><span class="line">EventUtil.addHandler(img,&quot;load&quot;,function(event)&#123;</span><br><span class="line">    event=EventUtil.getEvent(event);</span><br><span class="line">    alert(EventUtil.getTarget(event).src);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>unload事件：在文档被完全卸载后触发。<br>resize事件：当浏览器窗口被调整到一个新的高度或者宽度时就会触发resize事件。<br>scroll事件：页面中相应元素的变化。<br>blur事件：在元素失去焦点时触发。<br>focus事件：在元素获得焦点时触发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM2级事件处理程序&quot;&gt;&lt;a href=&quot;#DOM2级事件处理程序&quot; class=&quot;headerlink&quot; title=&quot;DOM2级事件处理程序&quot;&gt;&lt;/a&gt;DOM2级事件处理程序&lt;/h2&gt;&lt;p&gt;用于处理指定和删除事件处理程序的操作：addEventListene
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="JavaScript事件" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM2和DOM3</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/07/20/JavaScript-DOM2%E5%92%8CDOM3/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/07/20/JavaScript-DOM2和DOM3/</id>
    <published>2017-07-20T11:22:31.000Z</published>
    <updated>2018-06-09T09:32:00.236Z</updated>
    
    <content type="html"><![CDATA[<p>样式：<br>访问元素的样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myDiv=document.getElementById(&apos;oDiv&apos;);</span><br><span class="line">myDiv.style.backgroundColor=&apos;red&apos;;</span><br></pre></td></tr></table></figure></p><p>当设置多个样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myDiv=document.getElementById(&apos;oDiv&apos;);</span><br><span class="line">myDiv.style.cssText=&quot;width: 200px;background-color: red;&quot;;</span><br></pre></td></tr></table></figure></p><p>另外还能通过getPropertyValue()和getPropertyCssValue()方法来访问css样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myDiv=document.getElementById(&apos;oDiv&apos;);</span><br><span class="line">var prop,value,i;</span><br><span class="line">var len=myDiv.style.length;</span><br><span class="line">for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">    prop=myDiv.style.item(i);</span><br><span class="line">    value=myDiv.style.getPropertyValue(prop);</span><br><span class="line">    alert(prop+&quot;:&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">var myDiv=document.getElementById(&apos;oDiv&apos;);</span><br><span class="line">var prop,value,i;</span><br><span class="line">var len=myDiv.style.length;</span><br><span class="line">for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">    prop=myDiv.style.item(i);</span><br><span class="line">    value=myDiv.style.getPropertyCSSValue(prop);</span><br><span class="line">    alert(prop+&quot;:&quot;+value.cssText+&quot;(&quot;+value.cssValueType+&quot;)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>移除样式：<code>removeProperty()</code>。</p><p>元素大小<br>偏移量：<br>offsetHeight：元素在垂直方向上占用的空间大小<br>offsetWidth：元素在水平方向上占用的空间大小<br>offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。<br>offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。<br>要知道某个元素在页面上的偏移量，将这个元素的offsetLeft 和offsetTop 与其offsetParent的相同属性相加，如此循环直至根元素，就能得到一个基本准确的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getElementLeft(element)&#123;</span><br><span class="line">    var actualLeft=element.offsetLeft;</span><br><span class="line">    var current=element.offsetParent;</span><br><span class="line">    while(current!==null)&#123;</span><br><span class="line">        actualLeft+=current.offsetLeft;</span><br><span class="line">        current=current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return actualLeft;</span><br><span class="line">&#125;</span><br><span class="line">function getElementTop(element)&#123;</span><br><span class="line">    var actualTop=element.offsetTop;</span><br><span class="line">    var current=element.offsetParent;</span><br><span class="line">    while(actualTop!==null)&#123;</span><br><span class="line">        actualTop+=current.offsetTop;</span><br><span class="line">        current=current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return actualTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户区大小：元素内容及其内边距所占据的空间大小。<br>clientWidth 和clientHeight。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getViewport()&#123;</span><br><span class="line">    if(document.compatMode==&quot;BackCompat&quot;)&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            width:document.body.clientWidth;</span><br><span class="line">            height:document.body.clientHeight;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            width:document.documentElement.clientWidth;</span><br><span class="line">            height:document.documentElement.clientHeight;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>滚动大小：包含滚动内容的元素的大小。<br>scrollTop：在被隐藏在内容区域上方的像素数。<br>scrollLeft：在被隐藏在内容区域左侧的像素数。<br>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。<br>srcollHeight：在没有滚动条的情况下，元素内容的总高度。<br>注意：在确定文档的总高度时（包括基于视口的最小高度时），必须取得scrollWidth/clientWidth和scrollHeight/clientHeight中的最大值，才能保证在跨浏览器的环境下得到精确的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getViewport(element)&#123;</span><br><span class="line">    var docHeight,docWidth;</span><br><span class="line">    if(document.compatMode==&quot;BackCompat&quot;)&#123;</span><br><span class="line">        docWidth=Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth);</span><br><span class="line">        docHeight=Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        docWidth=Math.max(document.body.scrollWidth,document.body.clientWidth);</span><br><span class="line">        docHeight=Math.max(document.body.scrollHeight,document.body.clientHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过改变scrollTop和scrollLeft的值来确定元素当前滚动的状态。<br>scrollTop=0：回到顶部</p><p>确定元素大小：getBoundingClientRect()方法。包含四个属性：top,left,right,bottom。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function getBoundingClientRect(element)&#123;</span><br><span class="line">    if(typeof arguments.callee.offset!=&quot;number&quot;)&#123;</span><br><span class="line">        var scrollTop=document.documentElement.scrollTop;</span><br><span class="line">        var temp=document.createElement(&quot;div&quot;);</span><br><span class="line">        temp.style.cssText=&quot;position: absolute;left:0;top:0;&quot;;</span><br><span class="line">        document.body.appendChild(temp);</span><br><span class="line">        arguments.callee.offset=-temp.getBoundingClientRect().top-scrollTop;</span><br><span class="line">        document.body.removeChild(temp);</span><br><span class="line">        temp=null;</span><br><span class="line">    &#125;</span><br><span class="line">    var rect=element.getBoundingClientRect();</span><br><span class="line">    var offset=arguments.callee.offset;</span><br><span class="line">    return&#123;</span><br><span class="line">        left:rect.left+offset,</span><br><span class="line">        right:rect.right+offset,</span><br><span class="line">        top:rect.top+offset,</span><br><span class="line">        bottom:rect.bottom+offset</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了跨浏览器实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function getElementLeft(element)&#123;</span><br><span class="line">    var actualLeft=element.offsetLeft;</span><br><span class="line">    var current=element.offsetParent;</span><br><span class="line">    while(current!==null)&#123;</span><br><span class="line">        actualLeft+=current.offsetLeft;</span><br><span class="line">        current=current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return actualLeft;</span><br><span class="line">&#125;</span><br><span class="line">function getElementTop(element)&#123;</span><br><span class="line">    var actualTop=element.offsetTop;</span><br><span class="line">    var current=element.offsetParent;</span><br><span class="line">    while(actualTop!==null)&#123;</span><br><span class="line">        actualTop+=current.offsetTop;</span><br><span class="line">        current=current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return actualTop;</span><br><span class="line">&#125;</span><br><span class="line">function getBoundingClientRect(element) &#123;</span><br><span class="line">    var scrollTop = document.documentElement.scrolltop;</span><br><span class="line">    var scrollLeft = document.documentElement.scrollleft;</span><br><span class="line">    if(element.getBoundingClientRect) &#123;</span><br><span class="line">        if(typeof arguments.callee.offset != &quot;number&quot;) &#123;</span><br><span class="line">            var scrollTop = document.documentElement.scrollTop;</span><br><span class="line">            var temp = document.createElement(&quot;div&quot;);</span><br><span class="line">            temp.style.cssText = &quot;position: absolute;left:0;top:0;&quot;;</span><br><span class="line">            document.body.appendChild(temp);</span><br><span class="line">            arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop;</span><br><span class="line">            document.body.removeChild(temp);</span><br><span class="line">            temp = null;</span><br><span class="line">        &#125;</span><br><span class="line">        var rect = element.getBoundingClientRect();</span><br><span class="line">        var offset = arguments.callee.offset;</span><br><span class="line">        return &#123;</span><br><span class="line">            left: rect.left + offset,</span><br><span class="line">            right: rect.right + offset,</span><br><span class="line">            top: rect.top + offset,</span><br><span class="line">            bottom: rect.bottom + offset</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        var actualLeft=getElementLeft(element);</span><br><span class="line">        var actualTop=getElementTop(element);</span><br><span class="line">        return&#123;</span><br><span class="line">            left:actualLeft-scrollLeft,</span><br><span class="line">            right:actualLeft+element.offsetWidth-screenLeft,</span><br><span class="line">            top:actualTop-scrollTop,</span><br><span class="line">            bottom:actualTop+element.offsetHeight-screenTop</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;样式：&lt;br&gt;访问元素的样式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://qiuyuxiu.github.io/MyBlog/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM扩展</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/07/18/JavaScript-DOM%E6%89%A9%E5%B1%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/07/18/JavaScript-DOM扩展/</id>
    <published>2017-07-18T06:22:44.000Z</published>
    <updated>2018-06-09T09:29:02.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h2><p>querySelector()接收一个css选择符，返回与该模式匹配的第一个元素。<br>querySelectorAll()接收的参数也是css选择符，返回的是一个NodeList的实例。通过item()和方括号来访问它的每个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var body=document.querySelector(&quot;body&quot;);</span><br><span class="line">var div=document.querySelector(&quot;#div&quot;);</span><br><span class="line">var className=document.querySelector(&quot;.btn&quot;);</span><br><span class="line">var img=document.querySelector(&quot;img.button&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="元素遍历：跨浏览器遍历某元素的所有子元素"><a href="#元素遍历：跨浏览器遍历某元素的所有子元素" class="headerlink" title="元素遍历：跨浏览器遍历某元素的所有子元素;"></a>元素遍历：跨浏览器遍历某元素的所有子元素;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var i,len,child=element.firstChild;</span><br><span class="line">while(child!=element.lastChild)&#123;</span><br><span class="line">    if(child.nodeType==1)&#123;</span><br><span class="line">        processChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    child=child.nextSibling;</span><br><span class="line">&#125;</span><br><span class="line">var i,len,child=element.firstElementChild;</span><br><span class="line">while(child!=element.lastElementChild)&#123;</span><br><span class="line">    processChild(child);</span><br><span class="line">    child=child.nextElementSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML5<br>getElementByTagName()方法：接收一个参数，包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。<br>add(),contains(),remove(),toggle()方法都是之后类名进行操作。</p><p>焦点管理<br>focus()方法是元素获得了焦点。<br>hasFocus()方法用于确定文档是否获得了焦点。</p><p>插入标记<br>innerHTML属性：innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的HTML标记。并非所有元素都支持这个innerHTML属性，不支持innerHTML属性的有:<code>&lt;head&gt;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择符API&quot;&gt;&lt;a href=&quot;#选择符API&quot; class=&quot;headerlink&quot; title=&quot;选择符API&quot;&gt;&lt;/a&gt;选择符API&lt;/h2&gt;&lt;p&gt;querySelector()接收一个css选择符，返回与该模式匹配的第一个元素。&lt;br&gt;querySele
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/28/JavaScript-DOM/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/28/JavaScript-DOM/</id>
    <published>2017-06-28T07:22:49.000Z</published>
    <updated>2018-06-09T07:39:55.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p>1.nodeType属性：为了确保跨浏览器兼容，最好要将这个属性与数字值进行比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(someNode.nodeType==1)&#123;</span><br><span class="line">    alert(&quot;Node is an element!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.nodeName和nodeValue属性：<br>最好先判断是不是一个元素，再来取得并保存nodeName的值。nodeName中保存的始终是元素的标签名。</p><p>3.childNodes属性：有着NodeList对象，是一种类数组对象。子节点可以用方括号和item()方法来访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var firstChild=someNode.childNodes[0];</span><br><span class="line">var secondChild=someNode.childNodes.item(1);</span><br><span class="line">var count=someNode.childNodes.length;</span><br></pre></td></tr></table></figure></p><p>要将NodeList转换为数组，必须手动枚举所有成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function convertToArray(nodes)&#123;</span><br><span class="line">    var array=null;</span><br><span class="line">    try&#123;</span><br><span class="line">        array=Array.prototype.slice.call(nodes,0);//针对非ie浏览器</span><br><span class="line">    &#125;catch(ex)&#123;</span><br><span class="line">        array=new Array();</span><br><span class="line">        for(var i=0,len=nodes.length;i&lt;len;i++)&#123;</span><br><span class="line">            array.push(nodes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>parentNode属性：父节点<br>previousSibling属性和nextSibling属性：访问同一列表中的其他节点。同胞节点。<br>firstChild和lastChild属性：第一个节点和最后一个节点。<br>hasChildNodes()属性：在节点包含一或多个子节点的情况下返回true。</p><p>操作节点：<br>appendChild()方法：用于向childNodes列表的末尾添加一个节点。<br>insertBefore()方法：接受两个参数：要插入的节点和作为参照的节点。如果参照节点为null，则insertBefore()与appendChild()执行相同的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//插入后成为最后一个子节点</span><br><span class="line">returnedNode=someNode.insertBefore(newNode,null);</span><br><span class="line">alert(newValue==someNode.lastChild);//true</span><br><span class="line">//插入后成为第一个子节点</span><br><span class="line">var returnedNode=someNode.insertBefore(newNode,someNode.firstChild);</span><br><span class="line">alert(returnedNode==newValue);//true</span><br><span class="line">alert(newValue==someNode.firstChild);//true</span><br><span class="line">//插入后成为最后一个子节点之前</span><br><span class="line">returnedNode=someNode.insertBefore(newNode,someNode.lastChild);</span><br><span class="line">alert(newValue==someNode.childNodes[someNode.childNodes.length-2]);//true</span><br><span class="line">replaceChild() 方法：接受两个参数：要插入的节点和要替换的节点。</span><br><span class="line"></span><br><span class="line">//替换第一个节点</span><br><span class="line">var returnedNode=someNode.replaceChild(newNode,someNode.firstChild);</span><br><span class="line">//替换最后一个节点</span><br><span class="line">returnedNode=someNode.replaceChild(newNode,someNode.lastChild);</span><br><span class="line">removeChild()方法：接受一个参数：即要移除的节点。</span><br><span class="line"></span><br><span class="line">//移除第一个节点</span><br><span class="line">var returnedNode=someNode.removeChild(someNode.firstChild);</span><br><span class="line">//移除最后一个节点</span><br><span class="line">returnedNode=someNode.removeChild(someNode.lastChild);</span><br><span class="line">cloneNode()方法接受一个布尔值参数，用于创建调用这个方法的 节点的一个完全相同的副本。</span><br></pre></td></tr></table></figure></p><h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>documentElement属性始终指向HTML页面中的元素。<br>body属性直接指向元素。<br>所有浏览器都支持document.documentElement和document.body属性。<br>Document对象还有title属性，URL属性，domain属性和referrer属性。<br>查找元素：getElementById() 和getElementsByTagName()，前者接受元素的id，后者接受元素的标签名。<br>getElementsByName() 这个方法返回带有给定name特性的所有元素。</p><h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>在HTML中，标签名始终都以全部大写表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(element.tagName.toLowerCase()==&quot;div&quot;)&#123;</span><br><span class="line">    //在此执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>取得特性：<br>getAttribute()：获取相应的特性值。getAttribute(“id”);<br>setAttribute()：设置相应的特性值。setAttribute(“id”,”oDiv”);<br>removeAttribute()：移除相应的特性值。removeAttribute(“id”);<br>attributes属性：element.attributes.getNameItem()；element.attributes[“ “]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementsByTagName(&quot;button&quot;)[0];</span><br><span class="line">var id=btn.attributes.getNamedItem(&quot;id&quot;).nodeValue;</span><br><span class="line">alert(id);</span><br></pre></td></tr></table></figure></p><p>一般来说，这个属性的方法不太方便，一般都是选用getAttribute()、setAttribute()、removeAttribute()。<br>不过在遍历元素的特性时可以用上attributes属性的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function outputAttributes(element)&#123;</span><br><span class="line">    var pairs=new Array(),</span><br><span class="line">        attrName,</span><br><span class="line">        attrValue,</span><br><span class="line">        i,</span><br><span class="line">        len;</span><br><span class="line">    for(i=0,len=element.attributes.length;i&lt;len;i++)&#123;</span><br><span class="line">        attrName=element.attributes[i].nodeName;</span><br><span class="line">        attrValue=element.attributes[i].nodeValue;</span><br><span class="line">        pairs.push(attrName+&quot;=\&quot;&quot;+attrValue+&quot;\&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   return pairs.join(&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">function outputAttributes(element)&#123;</span><br><span class="line">    var pairs=new Array(),</span><br><span class="line">        attrName,</span><br><span class="line">        attrValue,</span><br><span class="line">        i,</span><br><span class="line">        len;</span><br><span class="line">    for(i=0,len=element.attributes.length;i&lt;len;i++)&#123;</span><br><span class="line">        attrName=element.attributes[i].nodeName;</span><br><span class="line">        attrValue=element.attributes[i].nodeValue;</span><br><span class="line">        if(element.attributes[i].specified)&#123;</span><br><span class="line">            pairs.push(attrName+&quot;=\&quot;&quot;+attrValue+&quot;\&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   return pairs.join(&quot;  &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建元素：<br>document.createElement()方法可以创建新元素。接受一个参数：即要创建元素的标签名。<br>创建之后可以使用appendChild(),insertBefore(),replaceChild()方法进行添加到文档树中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var div=document.createElement(&quot;div&quot;);</span><br><span class="line">div.className=&quot;oDiv&quot;;</span><br><span class="line">div.id=&quot;oDiv&quot;;</span><br><span class="line">document.body.appendChild(div);</span><br></pre></td></tr></table></figure></p><h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>创建文本节点：document.createTextNode()，接受一个参数：要插入节点中的文本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var div=document.createElement(&quot;div&quot;);</span><br><span class="line">div.className=&quot;oDiv&quot;;</span><br><span class="line">div.id=&quot;oDiv&quot;;</span><br><span class="line">var textNode=document.createTextNode(&quot;hello world!&quot;);</span><br><span class="line">div.appendChild(textNode);</span><br><span class="line">document.body.appendChild(div);</span><br></pre></td></tr></table></figure></p><p>当多个文本节点的时候可以使用normalize()方法来规范化。<br>分割文本节点：splitText()，按照指定的位置进行分割文本节点的nodeValue值。</p><h2 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h2><p>有3个属性：name,value,specified<br>document.createAttribute()传入特性的名称可以创建新的特性节点。之后必须使用setAttributeNode()进行添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var attribute=document.createAttribute(&quot;align&quot;);</span><br><span class="line">attribute.value=&quot;left&quot;;</span><br><span class="line">element.setAttributeNode(attribute);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Node类型&quot;&gt;&lt;a href=&quot;#Node类型&quot; class=&quot;headerlink&quot; title=&quot;Node类型&quot;&gt;&lt;/a&gt;Node类型&lt;/h2&gt;&lt;p&gt;1.nodeType属性：为了确保跨浏览器兼容，最好要将这个属性与数字值进行比较：&lt;br&gt;&lt;figure c
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://qiuyuxiu.github.io/MyBlog/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript BOM</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/20/JavaScript-BOM/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/20/JavaScript-BOM/</id>
    <published>2017-06-20T11:22:55.000Z</published>
    <updated>2018-06-09T07:25:06.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>在全局作用域中声明的变量、函数都会变成window对象的属性和方法。全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var age=29;</span><br><span class="line">function sayAge()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">alert(window.age);//29</span><br><span class="line">sayAge();//29</span><br><span class="line">window.sayAge();//29</span><br></pre></td></tr></table></figure></p><p>在全局作用域中定义了age变量和sayAge()方法，他们都属于window对象的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var age=29;</span><br><span class="line">window.color=&quot;red&quot;;</span><br><span class="line">delete window.age;</span><br><span class="line">delete window.color;</span><br><span class="line">alert(window.age);//29</span><br><span class="line">alert(window.color);//undefined</span><br></pre></td></tr></table></figure></p><p>可见全局变量age不可以删除，在window对象上的属性color可以被删除掉。</p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><p>screenLeft 和 screenTop 属性：用来表示窗口相对于屏幕左边和上边的位置。<br>screenX 和 screenY 属性：提供相同的窗口位置信息。<br>但两者支持的浏览器不同。下面的代码可以跨浏览器取得窗口左边和上边的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var leftPos=(typeof window.screenLeft==&apos;number&apos;)?window.screenLeft:window.screenX;</span><br><span class="line">var topPos=(typeof window.screenTop==&apos;number&apos;)?window.screenTop:window.screenY;</span><br><span class="line">document.write(leftPos+&quot;  &quot;+topPos);</span><br></pre></td></tr></table></figure></p><p>全屏的情况下值为0 0。<br>moveTo()和moveBy() 是将窗口移动到一个新位置。<br>moveTo() 接受的是新位置的x和y坐标值，而moveBy() 接受的是在水平和垂直方向上移动的像素数。 但是现在很多浏览器已经禁用了。</p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p>outerWidth和outerHeight返回浏览器窗口本身的尺寸；<br>innerWidth和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。<br>不同的浏览器支持的窗口大小的表示方式不同,因此也需要考虑浏览器兼容性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var pageWidth=window.innerWidth;</span><br><span class="line">var pageHeight=window.innerHeight;</span><br><span class="line">if(typeof pageWidth!=&apos;number&apos;)&#123;</span><br><span class="line">    if(document.compatMode==&quot;CSS1Compat&quot;)&#123;</span><br><span class="line">        pageWidth=document.documentElement.clientWidth;</span><br><span class="line">        pageHeight=document.documentElement.clientHeight;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        pageWidth=document.body.clientWidth;</span><br><span class="line">        pageHeight=document.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">document.write(pageWidth+&quot;   &quot;+pageHeight);</span><br></pre></td></tr></table></figure></p><p>resizeTo() 和 resizeBy() 方法可以调整浏览器窗口的大小。<br>resizeTo()接受的是窗口的新宽度和新高度，而resizeBy() 接受的是新窗口与原窗口的宽度和高度之差。不过现在有些浏览器也是禁用了的。</p><h4 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h4><p><code>window.open()</code> 方法可以接收四个参数：要加载的url，窗口目标，一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。第二个参数可以是：_self,_blank,_parent,_top。第三个参数可以是窗口的一些特性，例如width，height等等。<br><code>window.open(&quot; &quot;,&#39;myWin&#39;,&#39;width=200,height=200,top=100,left=50&#39;);</code><br><code>window.close()</code> 方法用来关闭窗口。<br>检验弹出窗口是否被屏蔽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bloked=false;</span><br><span class="line">try&#123;</span><br><span class="line">    var wroxWin=window.open(&quot;http://www.baidu.com&quot;,&apos;_blank&apos;);</span><br><span class="line">    if(wroxWin==null)&#123;</span><br><span class="line">        bloked=true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(ex)&#123;</span><br><span class="line">    bloked=true;</span><br><span class="line">&#125;</span><br><span class="line">if(bloked)&#123;</span><br><span class="line">    alert(&quot;The popup was bloked!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><p>setTimeout() 方法接受两个参数：要执行的代码和以毫秒表示的时间。<br>clearTimeout() 方法是取消超时调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var oBtn=document.getElementById(&apos;btn&apos;);</span><br><span class="line">var timeoutId=setTimeout(function()&#123;</span><br><span class="line">    alert(&quot;hello!&quot;);</span><br><span class="line">&#125;,1000);</span><br><span class="line">clearTimeout(timeoutId);</span><br></pre></td></tr></table></figure></p><p>设置间歇调用的方法是setInterval()。它接受的参数也是：要执行的代码和以毫秒表示的时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var num=0;</span><br><span class="line">var max=10;</span><br><span class="line">var intervalId=null;</span><br><span class="line">function incrementNumber()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    if(num==max)&#123;</span><br><span class="line">        clearInterval(intervalId);</span><br><span class="line">        alert(&quot;Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId=setInterval(incrementNumber,1000);</span><br><span class="line">var num=0;</span><br><span class="line">var max=10;</span><br><span class="line">function incrementNumber()&#123;</span><br><span class="line">    num++;</span><br><span class="line">    if(num&lt;max)&#123;</span><br><span class="line">        setTimeout(incrementNumber,1000);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        alert(&quot;Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber,1000);</span><br></pre></td></tr></table></figure></p><p>这两种表达方式的效果都是一样的。不过最好不要使用间歇调用。</p><h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><p>alert(),confirm(),prompt()方法可以调用系统对话框向用户显示信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result=prompt(&quot;What is your name?&quot;);</span><br><span class="line">if(result)&#123;</span><br><span class="line">    alert(&quot;welcome,&quot;+result);//welcome,...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>查询字符串参数，在开发的时候经常用到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function getQueryStringArgs()&#123;</span><br><span class="line">  //取得查询字符串并去掉开头的问号</span><br><span class="line">  var qs=(location.search.length &gt;0?location.search.substring(1)：&apos;&apos;);</span><br><span class="line">  //保存数据的对象</span><br><span class="line">  arg=&#123;&#125;;</span><br><span class="line">  var items=qs.length?qs.split(&apos;&amp;&apos;):[],</span><br><span class="line">      item=null,</span><br><span class="line">      name=null,</span><br><span class="line">      //在for循环中使用</span><br><span class="line">      i=0,</span><br><span class="line">      len=items.length;</span><br><span class="line">  //逐个将每一项添加到args对象中</span><br><span class="line">  for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">     item=items[i].split(&quot;=&quot;);</span><br><span class="line">     name=decodeURIComponent(item[0]);</span><br><span class="line">     value=decodeURIComponent(item[1]);</span><br><span class="line">     if(name.length)&#123;</span><br><span class="line">        args[name]=value;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如：要查询的字符串是?q=javascript&amp;num=10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var args=getQueryStringArgs();</span><br><span class="line">alert(args[&quot;q&quot;]);//javascript</span><br><span class="line">alert(args[&quot;num&quot;]);//10</span><br></pre></td></tr></table></figure></p><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location.assign(&quot;http://www.baidu.com&quot;);</span><br><span class="line">window.location=&quot;http://www.baidu.com&quot;;</span><br><span class="line">location.href=&quot;http://www.baidu.com&quot;;</span><br><span class="line">这三种表达方式效果都是一样，打开百度的网页。</span><br><span class="line">另外修改location的hash,search,hostname,pathname,port属性可以改变当前加载的页面。</span><br><span class="line">假设初始的URL为http://www.baidu.com/win/</span><br><span class="line">//修改为：http://www.baidu.com/win/#section1</span><br><span class="line">location.hash = “#section1”;</span><br><span class="line">//修改为：http://www.baidu.com/win/?q=JavaScript</span><br><span class="line">location.search = “?q=javascript”;</span><br><span class="line">//修改为：http://www.yahoo.com/win/</span><br><span class="line">location.hostname = “www.yahoo.com”</span><br><span class="line">//修改为：http://www.baidu.com/win/mydir</span><br><span class="line">location.pathname = “mydir”</span><br><span class="line">//修改为：http://www.baidu.com:8080/win/</span><br><span class="line">location.port = “8080”</span><br></pre></td></tr></table></figure><p>replace()函数在设置URL方面与location的href属性或assign函数完全一样，但是它会删除history对象的地址列表中的URL，从而使Go或back等函数无法导航。<br>reload()函数是用于重新加载当前显示的页面。一般最好将reload() 放在代码的最后一行。</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history() 中使用最常的就是go()方法。<br>后退一页：history.go(-1)<br>前进一页：history.go(1)<br>前进两页：history.go(2)<br>也可以指定网页跳转：history.go(“url”),后退：history().back(),前进：history.forward()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;window对象&quot;&gt;&lt;a href=&quot;#window对象&quot; class=&quot;headerlink&quot; title=&quot;window对象&quot;&gt;&lt;/a&gt;window对象&lt;/h2&gt;&lt;p&gt;在全局作用域中声明的变量、函数都会变成window对象的属性和方法。全局变量不能通过dele
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="BOM" scheme="https://qiuyuxiu.github.io/MyBlog/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript闭包问题</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript闭包问题/</id>
    <published>2017-06-17T05:23:11.000Z</published>
    <updated>2018-06-09T07:19:46.419Z</updated>
    
    <content type="html"><![CDATA[<p>函数的闭包：有权访问另一个函数作用域中的变量的函数。常见方式：在一个函数内部创建另一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertuName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1=object1[propertuName];</span><br><span class="line">        var value2=object2[propertuName];</span><br><span class="line">        if(value1&lt;value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1&gt;value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createFunction()&#123;</span><br><span class="line">    var result=new Array();</span><br><span class="line">    for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">        result[i]=function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">var funcs = createFunction();</span><br><span class="line">for (var i=0; i &lt; funcs.length; i++)&#123;</span><br><span class="line">    document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>createFunction()函数返回一个数组。表面上看，似乎每个函数都应该返回自己的索引值，但事实并非如此，事实上每个函数的返回值都是10.因为每个函数的作用域链中都包含着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值就是10，此时每个函数都引用着保存变量i的同一个变量对象，所以每个函数返回后都是10。</p><p>创建另一个匿名函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createFunction() &#123;</span><br><span class="line">    var result = new Array();</span><br><span class="line">    for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function(num) &#123;</span><br><span class="line">            return function() &#123;</span><br><span class="line">                return num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">var funcs = createFunction();</span><br><span class="line">for(var i = 0; i &lt; funcs.length; i++) &#123;</span><br><span class="line">    document.write(funcs[i]() + &quot;&lt;br /&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在重写了前面的createFunction()函数后，每个函数就会返回各自不同的索引值了。在这里，我们没有直接把闭包赋值给数值，而是定义了一个匿名函数，并将立即执行该函数的结果赋值给数组。这里的匿名函数有一个参数num,也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数参数按值传递的，所以就会将变量i的当前值复制给参数num。而在这个匿名函数内部，有创建并返回了一个访问num的闭包。这样依赖，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了。</p><p>闭包的作用：一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;　　　　</span><br><span class="line">    var n = 9;  　　　　</span><br><span class="line">    Add = function() &#123;</span><br><span class="line">        n += 1</span><br><span class="line">    &#125;   　　　　</span><br><span class="line">    function f2() &#123;　　　　　　</span><br><span class="line">        alert(n);　　　　</span><br><span class="line">    &#125;   　　　　</span><br><span class="line">    return f2;  　　</span><br><span class="line">&#125;　　</span><br><span class="line">var result = f1();　　</span><br><span class="line">result(); // 9　</span><br><span class="line">Add();　　</span><br><span class="line">result(); // 10</span><br></pre></td></tr></table></figure></p><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是9，第二次的值是10。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。一般将其设置为null可以删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function assignHandler()&#123;</span><br><span class="line">    var element=document.getElementById(&quot;someElement&quot;);</span><br><span class="line">    var id=element.id;</span><br><span class="line">    element.onclick=function()&#123;</span><br><span class="line">         alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    element=null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量的作用域<br>要理解闭包，首先必须理解Javascript特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量，在函数外部自然无法读取函数内的局部变量。</p><p>用闭包模拟私有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var Counter = (function() &#123;</span><br><span class="line">  var privateCounter = 0;</span><br><span class="line">  function changeBy(val) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    increment: function() &#123;</span><br><span class="line">      changeBy(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: function() &#123;</span><br><span class="line">      changeBy(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(Counter.value()); /* logs 0 */</span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line">console.log(Counter.value()); /* logs 2 */</span><br><span class="line">Counter.decrement();</span><br><span class="line">console.log(Counter.value()); /* logs 1 */</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数的闭包：有权访问另一个函数作用域中的变量的函数。常见方式：在一个函数内部创建另一个函数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="闭包" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Function类型</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-Function%E7%B1%BB%E5%9E%8B/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-Function类型/</id>
    <published>2017-06-17T03:43:27.000Z</published>
    <updated>2018-06-09T07:17:21.949Z</updated>
    
    <content type="html"><![CDATA[<p>作为值的函数：不仅可以像传递参数一样传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction,someArgument)&#123;</span><br><span class="line">    return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line">function add10(num)&#123;</span><br><span class="line">    return num+10;</span><br><span class="line">&#125;</span><br><span class="line">var result=callSomeFunction(add10,10);</span><br><span class="line">document.write(result);//20</span><br><span class="line">function getGreeting(name)&#123;</span><br><span class="line">    return &quot;hello, &quot;+name;</span><br><span class="line">&#125;</span><br><span class="line">var result2=callSomeFunction(getGreeting,&quot;Nike&quot;);</span><br><span class="line">document.write(result2);//hello, Nike</span><br></pre></td></tr></table></figure></p><p>sort()方法用到这种从一个函数返回另一个函数的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertuName)&#123;</span><br><span class="line">    return function(object1,object2)&#123;</span><br><span class="line">        var value1=object1[propertuName];</span><br><span class="line">        var value2=object2[propertuName];</span><br><span class="line">        if(value1&lt;value2)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(value1&gt;value2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var data=[&#123;name:&quot;Zachary&quot;,age:28&#125;,&#123;name:&quot;Nick&quot;,age:29&#125;];</span><br><span class="line">data.sort(createComparisonFunction(&quot;name&quot;));</span><br><span class="line">document.write(data[0].name);//Nick</span><br><span class="line">data.sort(createComparisonFunction(&quot;age&quot;));</span><br><span class="line">document.write(data[0].name);//Zachary</span><br></pre></td></tr></table></figure></p><p>函数内部属性：arguments 和 this<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num*factorial(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result=factorial(9);</span><br><span class="line">alert(result);</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num*arguments.callee(num-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result=factorial(9);</span><br><span class="line">alert(result);</span><br></pre></td></tr></table></figure></p><p>这两个函数执行的结果一样，都为362880。<br>函数属性和方法：<br>每个函数都包含两个属性：length和prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayName(name)&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">&#125;</span><br><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">    alert(&quot;hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">alert(sayName.length);//1</span><br><span class="line">alert(sum.length);//2</span><br><span class="line">alert(sayHi.length);//0</span><br></pre></td></tr></table></figure></p><p>每个函数包含两个非继承而来的方法apply()和call()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">function callSum2(num1,num2)&#123;</span><br><span class="line">    return sum.apply(this,[num1,num2]);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(10,10));//20</span><br><span class="line">alert(callSum2(10,10));//20</span><br></pre></td></tr></table></figure></p><p>call() 方法第二个参数是其余参数直接传递给函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1,num2)&#123;</span><br><span class="line">    return sum.call(this,num1,num2);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(10,10));//20</span><br></pre></td></tr></table></figure></p><p>在讨论javascript的继承中也用到了call()方法。</p><p>bind() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.color=&quot;red&quot;;</span><br><span class="line">var o=&#123;color:&quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor=sayColor.bind(o);</span><br><span class="line">objectSayColor();//blue</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为值的函数：不仅可以像传递参数一样传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="Function类型" scheme="https://qiuyuxiu.github.io/MyBlog/tags/Function%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 继承</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-%E7%BB%A7%E6%89%BF/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-继承/</id>
    <published>2017-06-17T02:27:36.000Z</published>
    <updated>2018-06-09T07:13:25.657Z</updated>
    
    <content type="html"><![CDATA[<p>原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property=true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty=false;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype=new SuperType();//继承SuperType</span><br><span class="line">SubType.prototype.getSubValue=function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.getSubValue());//false</span><br><span class="line">alert(instance.getSuperValue());//true</span><br></pre></td></tr></table></figure></p><p>注意：子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property=true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty=false;</span><br><span class="line">&#125;</span><br><span class="line">//继承SuperType</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">//添加新方法</span><br><span class="line">SubType.prototype.getSubValue=function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">//重写超类型中的方法</span><br><span class="line">SubType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.getSubValue());//false</span><br><span class="line">alert(instance.getSuperValue());//false</span><br><span class="line">不能使用对象字面量创建原型方法。</span><br></pre></td></tr></table></figure></p><p>原型链的问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">&#125;</span><br><span class="line">//继承</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">var instance=new SubType();</span><br><span class="line">instance.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance.colors);//red,blue,green,black</span><br><span class="line">var instance2=new SubType();</span><br><span class="line">alert(instance2.colors);//red,blue,green,black</span><br></pre></td></tr></table></figure></p><p>这个问题和在创建对象的时候也有，因为colors是共享属性。</p><p>借用构造函数：使用apply() 和call() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    //继承</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">instance.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance.colors);//red,blue,green,black</span><br><span class="line">var instance2=new SubType();</span><br><span class="line">alert(instance2.colors);//red,blue,green</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    //继承</span><br><span class="line">    SuperType.call(this,&quot;Nick&quot;);</span><br><span class="line">    this.age=29;</span><br><span class="line">&#125;</span><br><span class="line">var instance=new SubType();</span><br><span class="line">alert(instance.name);//Nick</span><br><span class="line">alert(instance.age);//29</span><br></pre></td></tr></table></figure></p><p>组合继承：将原型链和借用构造函数的技术组合到一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    thia.name=name;</span><br><span class="line">    this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName=function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">//继承方法</span><br><span class="line">SubType.prototype=new SuperType();</span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line">SubType.prototype.sayAge=function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var instance1=new SubType(&quot;Nick&quot;,29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);//red,blue,green,black</span><br><span class="line">instance1.sayName();//Nick</span><br><span class="line">instance1.sayAge();//29</span><br><span class="line">var instance2=new SubType(&quot;Greg&quot;,27);</span><br><span class="line">alert(instance1.colors);//red,blue,green</span><br><span class="line">instance1.sayName();//Greg</span><br><span class="line">instance1.sayAge();//27</span><br></pre></td></tr></table></figure></p><p>还有其他的一些继承方式比较少见的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="继承" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面向对象</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/17/JavaScript-面向对象/</id>
    <published>2017-06-17T01:23:49.000Z</published>
    <updated>2018-06-09T07:09:26.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>要修改对象的属性的默认的特性，必须使用Object.defineProperty() 方法。这个方法接受三个参数：属性所在的对象，属性的名字，一个描述符对象。描述符对象的属性必须是configurable,enumberable,writable,value。在不指定情况下，configurable,enumberable,writable这三个属性都是默认为false。<br>configurable设置为false 表示不能从对象中删除属性。writable设置为false表示是只读的，不能对属性进行赋值。enumberable表示能否通过for-in循环返回属性。</p><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>在读取访问器属性时，会调用getter函数；在写入访问器属性时，会调用setter函数并传入新值。<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;</span><br><span class="line">    _year:2004,</span><br><span class="line">    edition:1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function(newValue)&#123;</span><br><span class="line">        if(newValue&gt;2004)&#123;</span><br><span class="line">            this._year=newValue;</span><br><span class="line">            this.edition+=newValue-2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year=2005;</span><br><span class="line">alert(book.edition);//2</span><br></pre></td></tr></table></figure></p><p>定义多个属性：Object.defineProperties()方法。<br>读取属性的特征：Object.getOwnPropertyDescriptor()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        value:2004,</span><br><span class="line">        writable: true//这个必须写，不然不能下面book.year没有启用而起作用弹出2007，不然就弹出2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        value:1</span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        get:function()&#123;</span><br><span class="line">            return this._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function(newValue)&#123;</span><br><span class="line">            if(newValue&gt;2004)&#123;</span><br><span class="line">                this._year=newValue;</span><br><span class="line">                this.edition+=newValue-2004;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var descriptor=Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);</span><br><span class="line">alert(descriptor.value);//2004</span><br><span class="line">alert(descriptor.configurable);//false</span><br><span class="line">book.year=2007;</span><br><span class="line">alert(book._year);//2007</span><br></pre></td></tr></table></figure></p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>1.工厂模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o=new Object();</span><br><span class="line">    o.name=name;</span><br><span class="line">    o.age=age;</span><br><span class="line">    o.job=job;</span><br><span class="line">    o.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1=createPerson(&quot;Nick&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.sayName();//Nick</span><br><span class="line">alert(person2.name);//Greg</span><br></pre></td></tr></table></figure></p><p>2.构造函数模式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.job=job;</span><br><span class="line">    this.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1=new Person(&quot;Nick&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.sayName();//Nick</span><br><span class="line">alert(person2.name);//Greg</span><br></pre></td></tr></table></figure></p><p>3.原型模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=&quot;Nike&quot;;</span><br><span class="line">Person.prototype.age=29;</span><br><span class="line">Person.prototype.job=&quot;Engineer&quot;;</span><br><span class="line">Person.prototype.sayName=function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">person1.sayName();//Nike</span><br><span class="line">var person2=new Person();</span><br><span class="line">person2.sayName();//Nike</span><br><span class="line">alert(person1.sayName==person2.sayName);//true</span><br><span class="line">hasOwnProperty() 方法可以检测一个属性是否存在于实例中，还是存在于原型中。如果存在于对象实例中，则返回true。</span><br><span class="line">hasPrototypeProperty() 方法可以检测一个属性是否存在于实例中，还是存在于原型中。如果存在于对象原型中，则返回true。</span><br><span class="line">Object.keys() 方法接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</span><br></pre></td></tr></table></figure></p><p>更简单的原型语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  name: &quot;Nike&quot;,</span><br><span class="line">  age: 29,</span><br><span class="line">  job: &quot;Engineer&quot;,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>原型对象的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &quot;Nike&quot;,</span><br><span class="line">  job: &quot;Engineer&quot;,</span><br><span class="line">  friends: [&quot;Shelby&quot;,&quot;Court&quot;],</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1=new Person();</span><br><span class="line">var person2=new Person();</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);//Shelby,Court,Van</span><br><span class="line">alert(person2.friends);//Shelby,Court,Van</span><br><span class="line">alert(person1.friends==person2.friends);//true</span><br></pre></td></tr></table></figure></p><p>可以看到当改变一个对象的friends时，其他的对象的friends也跟着改变friends数组存在于person.prototype中，而不是存在于person1中，所以当改变person1的friends时候，person2的friends也变化。</p><p>4.组合使用构造函数模式和原型模式：构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">  this.job=job;</span><br><span class="line">  this.friends=[&quot;Shelby&quot;,&quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1=new Person(&quot;Nike&quot;,29,&quot;Engineer&quot;);</span><br><span class="line">var person2=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends);//Shelby,Court,Van</span><br><span class="line">alert(person2.friends);//Shelby,Court</span><br><span class="line">alert(person1.friends==person2.friends);//false</span><br><span class="line">alert(person1.sayName==person2.sayName);//true</span><br></pre></td></tr></table></figure></p><p>5.动态原型模式<br>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;) &#123; //在sayName()方法不存在的情况下，才会将它添加到原型中。instanceof操作符也可以</span><br><span class="line">        Person.prototype.sayName = function() &#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person(&quot;Nike&quot;, 29, &quot;Engineer&quot;);</span><br><span class="line">friend.sayName();//Nike</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h2&gt;&lt;p&gt;要修改对象的属性的默认的特性，必须使用Object.defineProperty() 方法。这个方法接受三个参数：属性所在的
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
