<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>有关于前端学习的个人博客</subtitle>
  <link href="/MyBlog/atom.xml" rel="self"/>
  
  <link href="https://qiuyuxiu.github.io/MyBlog/"/>
  <updated>2018-06-07T12:00:03.899Z</updated>
  <id>https://qiuyuxiu.github.io/MyBlog/</id>
  
  <author>
    <name>Daisy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git基本操作</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/14/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/14/Git基本操作/</id>
    <published>2017-06-14T01:36:54.000Z</published>
    <updated>2018-06-07T12:00:03.899Z</updated>
    
    <content type="html"><![CDATA[<p>最近都在研究着git，学习廖雪峰的官方网站的git教程，受益匪浅，就来整理记录下学到的知识。<br>git 是开发者，团队中不可获取的一个工具，熟悉使用它也是必要的。</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>在一些网站都可以下载。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><ol><li>创建新目录：mkdir learngit (也可以手动新建文件夹)</li><li>通过git init命令初始化git将其成为仓库。<br><code>git init</code></li><li><p>新建一个文本文件readme.txt，用Notepad++进行编写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaa from first</span><br></pre></td></tr></table></figure></li><li><p>往暂存区增加文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure></li><li><p>提交到master分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m “wrote a readme file”</span><br></pre></td></tr></table></figure></li></ol><p>一般-m 后面加一些提交信息比较好，方便查阅和之后优化与修改</p><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><ol><li>修改readme.txt 文件：<br><code>aaa from second</code></li><li>运行 <code>git status</code> 查看结果</li><li>运行 <code>git diff readme.txt</code> 查看不同，修改过的信息</li><li>之后 <code>git add readme.txt，git commit -m “…”</code>就能将修改之后的文件提交到master上。</li></ol><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ol><li>再次修改readme.txt文件：<br><code>aaa from third</code></li><li>之后<code>git add readme.txt</code>,<code>git commit -m “…”</code><br>到这之前有做了三个版本，<br>(1) aaa from first<br>(2) aaa from second<br>(3) aaa from third</li><li>运行<code>git log</code>查看日志</li><li>运行<code>git log –pretty=oneline</code>看到的日志比较易懂。</li><li>回退上一个版本：目前在第三个版本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li></ol><p>也可以使用<code>git reset –hard &lt;版本id&gt;</code><br>查看readme.txt 发现变成了<br>aaa from second</p><ol start="6"><li>也可以通过<code>commit id</code>来回退：<code>git reset –hard “commit id”</code></li><li>可以通过<code>git reflog</code>查看<code>commit id</code>(前6个字母)。</li></ol><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>命令<code>git checkout – readme.txt</code>意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p><ol><li>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure></li></ol><p>如果想要在commit之前，发现想要撤销修改，这个修改只添加到了暂存区，还没有提交。<br>命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p><h2 id="删除笔记"><a href="#删除笔记" class="headerlink" title="删除笔记"></a>删除笔记</h2><p><code>rm test.txt</code><br>一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code><br>另一种情况是删错了，因为版本库里还有，所以可以很轻松地把误删的文件恢复到最新版本：<br><code>git checkout – test.txt</code></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>配置SSH key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>找到电脑中的.ssh文件夹，将文件夹里的id_rsa.pub 文件里的公钥复制到github上的SSH Key上。</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><ol><li>先创建repository，复制到SSH 链接</li><li>之后运行： <code>git remote add origin “ssh链接”</code><br>其中origin是远程库的名字。</li><li>之后运行：<code>git add .</code>(添加所有文件)<br>添加单独文件：<code>git add index.html,test.html</code><br>之后运行：<code>git commit -m “提交的信息说明”</code></li><li>之后运行 <code>git push -u origin master</code> 进行推送到github库上，如果碰到有冲突问题，应该先pull下来之后再push，再新创建repository的时候不要勾选README,这样就<br>是一个空的repository 也就不会有冲突。</li><li>之后推送到github运行：<code>git push origin master</code> 即可。<br>注意：要是提醒文件不是个git仓库，则先<code>git init</code> 让他成为git仓库再进行提交。</li></ol><h2 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h2><p><code>git clone “你想要克隆的git的ssh链接或者https链接”</code></p><h2 id="修改远程库"><a href="#修改远程库" class="headerlink" title="修改远程库"></a>修改远程库</h2><p>三种方法：</p><ol><li><p>修改命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &quot;url&quot;</span><br></pre></td></tr></table></figure></li><li><p>先删后加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin &quot;url&quot;</span><br></pre></td></tr></table></figure></li><li><p>直接修改config文件</p></li></ol><h2 id="显示远程仓库"><a href="#显示远程仓库" class="headerlink" title="显示远程仓库"></a>显示远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 查看远程仓库信息</span><br></pre></td></tr></table></figure><p>git remote show origin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 远程仓库的删除和重命名</span><br><span class="line">重命名：</span><br></pre></td></tr></table></figure></p><p>git remote rename origin paul<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除：</span><br></pre></td></tr></table></figure></p><p>git remote rm paul<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 创建与合并分支</span><br><span class="line">1. 创建dev分支，然后切换到dev分支：`git checkout -b dev`</span><br><span class="line">2. git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</span><br></pre></td></tr></table></figure></p><p>git branch dev<br>git checkout dev<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3. 用`git branch`命令查看当前分支</span><br><span class="line">4. 切换回master分支：`git checkout master`</span><br><span class="line">5. 把dev分支的工作成果合并到master分支上：`git merge dev`</span><br><span class="line">6. 删除dev分支:`git branch -d/-D dev`</span><br><span class="line"></span><br><span class="line">## 解决冲突</span><br><span class="line">1. 如果修改文件提交上有冲突的话，在提交的时候会有提示，这时候打开文件就能看到Git用`&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;`标记出不同分支的内容，</span><br><span class="line">之后手动修改在`git add,git commit`就ok了。</span><br><span class="line">2. 用带参数的`git log`也可以看到分支的合并情况：</span><br></pre></td></tr></table></figure></p><p>git log –graph –pretty=oneline –abbrev-commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##分支操作</span><br><span class="line">- 远程仓库：</span><br><span class="line">1. 查看远程仓库：</span><br><span class="line">`git branch -r`</span><br><span class="line">2. 删除远程仓库：</span><br><span class="line">`git push origin --delete &lt;branchName&gt;`</span><br><span class="line">`git branch -r -d &lt;branchName&gt;`</span><br><span class="line">`git push origin :&lt;branchName&gt;`</span><br><span class="line">注意：`git branch -d -r &lt;branchname&gt;`删除远程分支，其中为本地分支名，删除后，还要推送到服务器上才行，即`git push origin`</span><br><span class="line">3. 由于`git branch (-m | -M) &lt;oldbranch&gt; &lt;newbranch&gt;`中是强制重命名，所以对于远程仓库的重命名最好使用：</span><br><span class="line">1）删除远程待修改分支</span><br><span class="line">2）push本地新分支名到远程</span><br><span class="line"></span><br><span class="line">- 本地仓库：</span><br><span class="line">1. 重命名本地分支：</span><br><span class="line">`git branch -m devel develop`</span><br><span class="line">2. 删除分支：</span><br><span class="line">`git branch -D &lt;branchName&gt;`</span><br><span class="line"></span><br><span class="line">## 修改提交信息commit</span><br><span class="line">1.输入`git commit --amend`,就会进入一个文本编辑界面，在注释的地方修改 ，保存然后退出，这样注释就修改了，再重新push.</span><br><span class="line">(1)用`rebase -i`，首先选择要修改的提交。</span><br><span class="line">`git rebase -i HEAD`</span><br><span class="line">进入一个文本编辑器</span><br><span class="line">(2)修改commit信息</span><br><span class="line">(3)若要通知这个提交的操作已经结束，请指定 –continue选项执行rebase。</span><br><span class="line">`git rebase --continue`</span><br><span class="line"></span><br><span class="line">## 回退版本</span><br><span class="line">1）使用`git log`命令查看所有的历史版本，获取某个历史版本的id</span><br><span class="line">2）`git reset --hard &lt;id&gt;`</span><br><span class="line">3）把修改推到远程服务器</span><br><span class="line">`git push -f -u origin master`</span><br><span class="line"></span><br><span class="line">## git中一些选项解释</span><br><span class="line">-d</span><br><span class="line">–delete：删除</span><br><span class="line">-D</span><br><span class="line">–delete –force的快捷键</span><br><span class="line">-f</span><br><span class="line">–force：强制</span><br><span class="line">-m</span><br><span class="line">–move：移动或重命名</span><br><span class="line">-M</span><br><span class="line">–move –force的快捷键</span><br><span class="line">-r</span><br><span class="line">–remote：远程</span><br><span class="line">-a</span><br><span class="line">–all：所有</span><br><span class="line"></span><br><span class="line">## vim命令</span><br><span class="line">- 模式：</span><br><span class="line">正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空</span><br><span class="line">插入模式（按i键进入） 左下角显示–INSERT–</span><br><span class="line">可视模式（不知道如何进入） 左下角显示–VISUAL–</span><br><span class="line"></span><br><span class="line">- 插入命令：</span><br></pre></td></tr></table></figure></p><p>i 在当前位置生前插入<br>I 在当前行首插入<br>a 在当前位置后插入<br>A 在当前行尾插入<br>o 在当前行之后插入一行<br>O 在当前行之前插入一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 查找命令：</span><br><span class="line">`/text` 查找text，按n健查找下一个，按N健查找前一个。</span><br><span class="line">`?text` 查找text，反向查找，按n健查找下一个，按N健查找前一个。</span><br><span class="line">vim中有一些特殊字符在查找时需要转义　　.[]^%/?~$</span><br><span class="line">`:set ignorecase`　忽略大小写的查找</span><br><span class="line">`:set noignorecase`　不忽略大小写的查找</span><br><span class="line">查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</span><br><span class="line">`:set hlsearch`　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</span><br><span class="line">`:set nohlsearch`　关闭高亮搜索显示</span><br><span class="line">`:nohlsearch`　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</span><br><span class="line">`:set incsearch`　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</span><br><span class="line">`:set wrapscan`　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</span><br><span class="line"></span><br><span class="line">- 退出命令：</span><br></pre></td></tr></table></figure></p><p>:q  ——退出（这是 :quit 的缩写）<br>:q! ——不保存退出（这是  :quit! 的缩写）<br>:wq ——写入文件并退出；（这是 :writequit 的缩写）<br>:wq! ——（如果文件只有读权限）写入并退出（如果文件没有写权限，强制写）<br>:x ——类似于 :wq，如果文件无变动，那就不写入<br>:qa ——退出全部（这是 :quitall 的缩写）<br>ZZ —— （大写的 Z）如果文件有变动，写入/保存，然后退出；<br>ZQ —— 如果不想保存文件，也可以这个命令退出；<br><code>`</code></p><p>其他参考:<a href="http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">Vim命令</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近都在研究着git，学习廖雪峰的官方网站的git教程，受益匪浅，就来整理记录下学到的知识。&lt;br&gt;git 是开发者，团队中不可获取的一个工具，熟悉使用它也是必要的。&lt;/p&gt;
&lt;h2 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Git" scheme="https://qiuyuxiu.github.io/MyBlog/categories/Git/"/>
    
    
      <category term="Git" scheme="https://qiuyuxiu.github.io/MyBlog/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>BFC与IFC</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/13/BFC%E4%B8%8EIFC/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/13/BFC与IFC/</id>
    <published>2017-06-13T11:21:50.000Z</published>
    <updated>2018-06-07T11:31:36.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC：独立的渲染区域，与这个区域外部毫不相干</p><ul><li>条件：</li></ul><ol><li>根元素或其它包含它的元素</li><li>浮动 (元素的 float 不是 none)</li><li>绝对定位的元素 (元素具有 position 为 absolute 或 fixed)</li><li>非块级元素具有 display: inline-block，table-cell, table-caption, flex, inline-flex</li><li>块级元素具有overflow ，且值不是 visible</li></ol><ul><li>作用：</li></ul><ol><li>利用BFC阻止文本换行</li><li>自适应两栏布局，不受float影响;</li><li>清除内部浮动，计算浮动高度；</li><li>防止垂直margin重叠：overflow:hidden。</li></ol><p>关于BFC:</p><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的左外边缘（margin-left)， 与包含块的左边（contain box left）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ol><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p>IFC：线框高度由其行内元素中最高的实际高度计算而来（不受竖直方向中的padding和margin影响）<br>IFC: font-size,line-height,height,vertical-align</p><p>资料查询：<br><a href="https://segmentfault.com/a/1190000009545742" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009545742</a><br><a href="http://www.cnblogs.com/Candybunny/p/6222939.html" target="_blank" rel="noopener">http://www.cnblogs.com/Candybunny/p/6222939.html</a><br><a href="http://www.myronliu.com/2016/03/04/css/css%E5%B8%83%E5%B1%80-BFC%E5%92%8CIFC/" target="_blank" rel="noopener">http://www.myronliu.com/2016/03/04/css/css%E5%B8%83%E5%B1%80-BFC%E5%92%8CIFC/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;headerlink&quot; title=&quot;BFC&quot;&gt;&lt;/a&gt;BFC&lt;/h2&gt;&lt;p&gt;BFC：独立的渲染区域，与这个区域外部毫不相干&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;根元素或其
      
    
    </summary>
    
      <category term="CSS" scheme="https://qiuyuxiu.github.io/MyBlog/categories/CSS/"/>
    
    
      <category term="BFC" scheme="https://qiuyuxiu.github.io/MyBlog/tags/BFC/"/>
    
      <category term="IFC" scheme="https://qiuyuxiu.github.io/MyBlog/tags/IFC/"/>
    
      <category term="CSS" scheme="https://qiuyuxiu.github.io/MyBlog/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/13/浏览器缓存机制/</id>
    <published>2017-06-13T05:13:26.000Z</published>
    <updated>2018-06-07T10:53:11.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h2><p>缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的HTTP头部来清晰地表达。<br>当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：</p><ol><li>本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；</li><li>协商缓存阶段：如果在本地缓存找到对应的资源，但是如果该资源已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</li><li>缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回404。</li></ol><h2 id="用户操作行为与缓存"><a href="#用户操作行为与缓存" class="headerlink" title="用户操作行为与缓存"></a>用户操作行为与缓存</h2><p><img src="../../../../images/pic5.png" alt="用户操作行为与缓存图"></p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>本地缓存阶段</p><ul><li>Expires:指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires。如果expires到期需要重新请求。</li><li>Cache-Control:cache-control优先级高于expires。<br>cache-control值:public,no-cache,no-store,max-age,min-fresh,max-stale.</li></ul><ol><li>public:表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</li><li>private:表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。</li><li>no-cache:强制所有缓存了该响应的缓存用户，在使用已存储的缓存数据前，发送带验证器的请求到原始服务器。</li><li>only-if-cached：表明如果缓存存在，只使用缓存，无论原始服务器数据是否有更新。</li><li>max-age=：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</li><li>max-stale[=]：表面客户端愿意接收一个已经过期的资源。 可选的设置一个时间(单位秒)，表示响应不能超过的过时时间。</li><li>min-fresh=：表示客户端希望在指定的时间内获取最新的响应。</li><li>must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。<br>详细见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</a></li></ol><h2 id="last-modified-if-modified-since"><a href="#last-modified-if-modified-since" class="headerlink" title="last-modified/if-modified-since"></a>last-modified/if-modified-since</h2><p>last-modified:表示这个响应资源的最后修改时间。<br>if-modified-since:当资源过期了(max-age)，发现资源有last-modified声明，则再次向服务器请求带上头部if-modified-since表示请求时间。web服务器收到之后发现有头部if-modified-since则与last-modified比较，如果last-modified比较新，则改动过，则响应整片内容；如果last-modified比较旧，则无修改，响应http304状态码，告诉浏览器继续使用所保存的cache。</p><h2 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h2><p>expires 是比较老的强缓存，是服务器返回的一个时间。<br>强缓存：为这些静态资源全部配置一个超时时间较长的expires或cache-control，这样用户在第一次加载时从服务器请求静态资源，其他时间只要缓存没有失效并用户没有强制刷新的条件下都会从自己的缓存中加载。<br>使用缓存，如果版本更新，在修改过的url加上时间戳，或者修改原本的时间戳。<br>强缓存–&gt;协商缓存(利用last-modified,if-modified-since,etag,if-none-match)</p><p>刷新：ctrl+f5: 跳过强缓存和协商缓存<br>f5: 跳过强缓存，会检查协商缓存</p><p>资源参考：<br><a href="http://imweb.io/topic/55c6f9bac222e3af6ce235b9" target="_blank" rel="noopener">http://imweb.io/topic/55c6f9bac222e3af6ce235b9</a><br><a href="https://segmentfault.com/a/1190000006689795" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006689795</a><br><a href="http://imweb.io/topic/55c6f9bac222e3af6ce235b9" target="_blank" rel="noopener">http://imweb.io/topic/55c6f9bac222e3af6ce235b9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP缓存机制&quot;&gt;&lt;a href=&quot;#HTTP缓存机制&quot; class=&quot;headerlink&quot; title=&quot;HTTP缓存机制&quot;&gt;&lt;/a&gt;HTTP缓存机制&lt;/h2&gt;&lt;p&gt;缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的HTTP头部来
      
    
    </summary>
    
      <category term="缓存" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="缓存" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>优化策略</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/13/%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/13/优化策略/</id>
    <published>2017-06-13T04:08:06.000Z</published>
    <updated>2018-06-07T10:49:18.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><p>最佳优化渲染路径：最小化关键资源的数量，字节数，长度</p><ol><li>js的异步加载：<br><code>&lt;script async src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></li><li>使用预处理器less，scss，sass等等。</li><li>Jquery的使用：id选择获取最快；使用for不适用each，能不用jq获取属性的时候可以不用，例如 this.id 获取id就不用 $(this).attr(“id”);</li></ol><h2 id="图片优化方案"><a href="#图片优化方案" class="headerlink" title="图片优化方案"></a>图片优化方案</h2><ol><li>使用base4 编码代替图片</li><li>合并图片雪碧图</li><li>使用css，svg，canvas或iconfont（font-awesome/阿里的iconfont）代替图片</li><li>css中使用after，before实现一些图形</li><li>压缩合并，CDN.缓存，延时加载，独立域名</li><li>tinypng：压缩图片网站，减少颜色数量，24png-&gt;8png</li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li><p>使用DocumentFragments或innerHTML取代复杂的元素注入。对于追加多条列表标签，最好采用先将这些标签追加到一个变量中，再使用innerHTML进行赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var htmlStr = &apos;&apos;;</span><br><span class="line">ajaxResult.items.forEach(function(item) &#123;</span><br><span class="line">// 构建包含HTML页面内容的字符串</span><br><span class="line">htmlStr += &apos;&lt;li&gt;&apos; + item.text + &apos;&lt;/li&gt;&apos;; &#125;);</span><br><span class="line">// 通过innerHTML设定ul内容</span><br><span class="line">document.querySelector(&apos;ul&apos;).innerHTML = htmlStr;</span><br></pre></td></tr></table></figure></li><li><p>高频执行事件/方法的防抖<br>对于滚动条或者一些滚动监听事件，如果触发过快就会影响性能，故需要做一些防抖动的操作。通常，开发人员会在有用户交互参与的地方添加事件，而往往这种事件会被频繁触发。想象一下窗口的resize事件或者是一个元素的onmouseover事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。<br>而防抖可以限制一个方法在一定时间内执行的次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 取自 UnderscoreJS 实用框架</span><br><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">var timeout;</span><br><span class="line">return function() &#123;</span><br><span class="line">  var context = this, args = arguments;</span><br><span class="line">  var later = function() &#123;</span><br><span class="line">  timeout = null;</span><br><span class="line">  if (!immediate)</span><br><span class="line">    func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  var callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">  clearTimeout(timeout);</span><br><span class="line">  timeout = setTimeout(later, wait);</span><br><span class="line">  if (callNow)</span><br><span class="line">    func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 添加resize的回调函数，但是只允许它每300毫秒执行一次</span><br><span class="line">window.addEventListener(&apos;resize&apos;, debounce(function(event) &#123;</span><br><span class="line">// 这里写resize过程</span><br><span class="line">&#125;, 300));</span><br></pre></td></tr></table></figure></li></ol><p>debounce方法返回一个方法，用来包住你的回调函数，限制他的执行频率。使用这个防抖方法，就可以让你写的频繁回调的方法不会妨碍用户的浏览器！</p><p>参考<a href="http://www.imooc.com/article/1647" target="_blank" rel="noopener">http://www.imooc.com/article/1647</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;渲染优化&quot;&gt;&lt;a href=&quot;#渲染优化&quot; class=&quot;headerlink&quot; title=&quot;渲染优化&quot;&gt;&lt;/a&gt;渲染优化&lt;/h2&gt;&lt;p&gt;最佳优化渲染路径：最小化关键资源的数量，字节数，长度&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;js的异步加载：&lt;br&gt;&lt;code&gt;&amp;lt;
      
    
    </summary>
    
      <category term="优化" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="优化" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Node.js文件操作</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/Node-js%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/Node-js文件操作/</id>
    <published>2017-06-12T09:54:43.000Z</published>
    <updated>2018-06-07T10:04:05.061Z</updated>
    
    <content type="html"><![CDATA[<p>引入文件系统模块<br><code>var fs = require(&quot;fs&quot;);</code><br>使用readFile和writeFile进行操作<br>读取文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">exports.t1=function()&#123;</span><br><span class="line">    console.log(&quot;开始读取文件！&quot;);</span><br><span class="line">    fs.readFile(&quot;./hello.js&quot;,function(err,data)&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            return console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(data.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">    //异步处理</span><br><span class="line">    var data=fs.readFileSync(&quot;./hello.js&quot;);</span><br><span class="line">    console.log(data.toString());</span><br><span class="line">    console.log(&quot;文件读取结束！&quot;);</span><br><span class="line">    //同步处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复制文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exports.copy1=function()&#123;</span><br><span class="line">    fs.readFile(&quot;./hello.js&quot;,function(err,data)&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            return console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.writeFile(&quot;./hello_c.js&quot;,data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用open，read，write进行操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">exports.t2 = function() &#123;</span><br><span class="line">    var buf = new Buffer(1024);</span><br><span class="line">    fs.open(&quot;./hello.js&quot;, &quot;r&quot;, function(err, fd) &#123;</span><br><span class="line">        if(err) &#123;</span><br><span class="line">            return console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.read(fd, buf, 0, buf.length, 0, function(err, bytes) &#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">                return console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;一共读取了&quot; + bytes + &quot;字节&quot;);</span><br><span class="line">            console.log(buf.slice(0, bytes).toString());</span><br><span class="line">        &#125;);</span><br><span class="line">        fs.close(fd, function(err) &#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">                return console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">exports.copy2 = function() &#123;</span><br><span class="line">    var buf = new Buffer(1024);</span><br><span class="line">    fs.open(&quot;./hello.js&quot;, &quot;r&quot;, function(err, rd) &#123;</span><br><span class="line">        if(err) &#123;</span><br><span class="line">            return console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.read(rd, buf, 0, buf.length, 0, function(err, bytes) &#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">                return console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">            fs.open(&quot;./hello_c.js&quot;, &quot;w&quot;, function(err, wd) &#123;</span><br><span class="line">                if(err) &#123;</span><br><span class="line">                    return console.log(err);</span><br><span class="line">                &#125;</span><br><span class="line">                fs.write(wd,buf,0,bytes,function(err,written,buffer)&#123;</span><br><span class="line">                    fs.close(wd, function(err) &#123;</span><br><span class="line">                        if(err) &#123;</span><br><span class="line">                            return console.log(err);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    console.log(written);</span><br><span class="line">                    if(err) &#123;</span><br><span class="line">                            return console.log(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        fs.close(rd, function(err) &#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">                return console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用事件循环进行操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">exports.copy3=function()&#123;</span><br><span class="line">    var buf = new Buffer(1024);</span><br><span class="line">    var eventEmitter=new event.EventEmitter();</span><br><span class="line">    eventEmitter.on(&quot;copy.star&quot;,function()&#123;</span><br><span class="line">        fs.open(&apos;./hello.js&apos;,&apos;r&apos;,function(err,rd)&#123;</span><br><span class="line">            if(err)&#123;</span><br><span class="line">                return console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">            eventEmitter.emit(&quot;copy.read&quot;,rd);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).on(&quot;copy.read&quot;,function(rd)&#123;</span><br><span class="line">        fs.read(rd,buf,0,buf.length,0,function(err,bytes)&#123;</span><br><span class="line">            fs.close(rd,function(err)&#123;</span><br><span class="line">                if(err)&#123;</span><br><span class="line">                    return console.log(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            if(err)&#123;</span><br><span class="line">                return console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">            eventEmitter.emit(&quot;copy.write&quot;,bytes);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).on(&quot;copy.write&quot;,function(bytes)&#123;</span><br><span class="line">        fs.open(&quot;./hello_c.js&quot;,&quot;w&quot;,function(err,wd)&#123;</span><br><span class="line">            if(err)&#123;</span><br><span class="line">                return console.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">            fs.write(wd,buf,0,bytes,function(err,writen,buffer)&#123;</span><br><span class="line">                fs.close(wd,function(err)&#123;</span><br><span class="line">                    if(err)&#123;</span><br><span class="line">                        return console.log(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                if(err)&#123;</span><br><span class="line">                        return console.log(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).emit(&quot;copy.star&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当复制内容超过规定的数值的时候，就会出错，所以可以使用createReadStream，createWriteStream方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exports.t3=function()&#123;</span><br><span class="line">    var read=fs.createReadStream(&quot;./hello.js&quot;);</span><br><span class="line">    read.on(&quot;data&quot;,function(data)&#123;</span><br><span class="line">        console.log(data.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">    read.on(&quot;end&quot;,function()&#123;</span><br><span class="line">        console.log(&quot;文件读取结束！&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exports.copy4=function()&#123;</span><br><span class="line">    var read=fs.createReadStream(&quot;./hello.js&quot;);</span><br><span class="line">    var write=fs.createWriteStream(&quot;./hello_c.js&quot;);</span><br><span class="line">    read.on(&quot;data&quot;,function(data)&#123;</span><br><span class="line">        write.write(data);</span><br><span class="line">    &#125;);</span><br><span class="line">    read.on(&quot;end&quot;,function()&#123;</span><br><span class="line">        write.end()</span><br><span class="line">    &#125;);</span><br><span class="line">    read.on(&quot;error&quot;,function(err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的方法，使用管道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.copy5=function()&#123;</span><br><span class="line">    var read=fs.createReadStream(&quot;./hello.js&quot;);</span><br><span class="line">    var write=fs.createWriteStream(&quot;./hello_c.js&quot;);</span><br><span class="line">    read.pipe(write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://nodejs.cn/api/" target="_blank" rel="noopener">nodejs 的文件系统API</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引入文件系统模块&lt;br&gt;&lt;code&gt;var fs = require(&amp;quot;fs&amp;quot;);&lt;/code&gt;&lt;br&gt;使用readFile和writeFile进行操作&lt;br&gt;读取文件内容：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="NodeJs" scheme="https://qiuyuxiu.github.io/MyBlog/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="https://qiuyuxiu.github.io/MyBlog/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>CSS知识</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/CSS%E7%9F%A5%E8%AF%86/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/CSS知识/</id>
    <published>2017-06-12T09:05:08.000Z</published>
    <updated>2018-06-07T09:45:43.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。<br>有标准盒子模型，IE盒子模型。标准盒子模型的元素宽度是元素的内容content的width；IE盒子模型元素的宽度则包括content的width+padding+border。<br>CSS3中新增了一种盒模型计算方式：box-sizing熟悉。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下：</p><ul><li>content-box（默认）</li></ul><ol><li><p>布局所占宽度Width：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Width = width + padding-left + padding-right + border-left + border-right</span><br></pre></td></tr></table></figure></li><li><p>布局所占高度Height:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Height = height + padding-top + padding-bottom + border-top + border-bottom</span><br></pre></td></tr></table></figure></li></ol><ul><li>padding-box</li></ul><ol><li><p>布局所占宽度Width：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Width = width(包含padding-left + padding-right) + border-top + border-bottom</span><br></pre></td></tr></table></figure></li><li><p>布局所占高度Height:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</span><br></pre></td></tr></table></figure></li></ol><ul><li>border-box</li></ul><ol><li><p>布局所占宽度Width：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Width = width(包含padding-left + padding-right + border-left + border-right)</span><br></pre></td></tr></table></figure></li><li><p>布局所占高度Height:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</span><br></pre></td></tr></table></figure></li></ol><h2 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h2><ol><li>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</li><li>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</li><li>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</li></ol><h2 id="文字溢出"><a href="#文字溢出" class="headerlink" title="文字溢出"></a>文字溢出</h2><p>text-overflow(对溢出的文字使用省略号)</p><ol><li><p>单行文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure></li><li><p>多行文字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">display:-webkit-box;</span><br><span class="line">-webkit-line-clamp:1;(行数)</span><br><span class="line">-webkit-box-orient:vertical;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CSS实现垂直水平居中"><a href="#CSS实现垂直水平居中" class="headerlink" title="CSS实现垂直水平居中"></a>CSS实现垂直水平居中</h2><ol><li>line-height: 高度;text-align：center;单行文字，图片</li><li>绝对定位居中：<br>(1)margin:0 auto;position: absolute;top:50%;left:0;right:0;bottom:0;margin-top:-(height/2);<br>(2)margin:auto;position: absolute;top:0;left:0;right:0;bottom:0;<br>(3)不知道高度时候：position: absolute;top:50%;left:50%;transform: translate(-50%,-50%);</li><li>模拟表格效果：IE6-IE7不支持<br>父元素：display:table;<br>子元素：display:table-cell;vertical-align:middle;</li><li><p>使用display:inline-block; 借用另一个元素的高度。（少用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;vertically-center&quot;&gt;</span><br><span class="line">    &lt;p&gt;aaabbb&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;extra&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">html,body&#123;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br><span class="line">#parent:&#123;height:500px;&#125;</span><br><span class="line">#vertical-center,#extra&#123;display:inline-block;vertical-align:middle;&#125;</span><br><span class="line">#extra&#123;height:100%;&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行内容居中：padding值设置。</p></li><li>使用flexbox：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display:flex;justify-content:center;align-items:center;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CSS-Hack"><a href="#CSS-Hack" class="headerlink" title="CSS Hack"></a>CSS Hack</h2><p>一般来说是针对不同的浏览器写不同的CSS,就是 CSS Hack。<br>IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：</p><ol><li><p>条件Hack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if IE]&gt;</span><br><span class="line">   &lt;style&gt;</span><br><span class="line">      .test&#123;color:red;&#125;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性Hack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  color:#090\9; /* For IE8+ */</span><br><span class="line">  *color:#f00;  /* For IE7 and earlier */</span><br><span class="line">  _color:#ff0;  /* For IE6 and earlier */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>选择符Hack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* html .test&#123;color:#090;&#125;       /* For IE6 and earlier */</span><br><span class="line">* + html .test&#123;color:#ff0;&#125;     /* For IE7 */</span><br></pre></td></tr></table></figure></li></ol><h2 id="px和em的区别"><a href="#px和em的区别" class="headerlink" title="px和em的区别"></a>px和em的区别</h2><p>px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em的值不是固定的，并且em会继承父级元素的字体大小。<br>浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em<br>rem是以根元素的字体大小为参照，即以html，body的font-size作为参照，所以rem是手机适配设置的方法之一。</p><h2 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h2><ul><li>background-size<br>对图片的铺满等设置：一般使用background-image,background-size:cover/contain/100%…<br>渐变问题：background:linear-gradient(top/bottom/角度…,fromColor,toColor);</li><li><p>opacity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opacity:0.5;</span><br><span class="line">filter:alpha(opacity=0.5)</span><br></pre></td></tr></table></figure></li><li><p>transform</p></li></ul><ol><li>transform:skew()/translate()/rotate()/scale()/matrix();</li><li>transition:(过渡) 样式 0.5s linear;</li><li>transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);<br>详情见 <a href="http://www.w3school.com.cn/cssref/pr_transition.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/cssref/pr_transition.asp</a></li></ol><ul><li>background<br>backface-visibility:hidden;不可见<br>background-clip:背景的边界不同 (content-box,border-box,padding-box);相当于截图</li><li>column<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.three-column&#123;</span><br><span class="line">padding: 1em;</span><br><span class="line">-moz-column-count: 3;</span><br><span class="line">-moz-column-gap: 1em;</span><br><span class="line">-webkit-column-count: 3;</span><br><span class="line">-webkit-column-gap: 1em;</span><br><span class="line">column-count: 3;</span><br><span class="line">column-gap: 1em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三个兼容浏览器的css前缀"><a href="#三个兼容浏览器的css前缀" class="headerlink" title="三个兼容浏览器的css前缀"></a>三个兼容浏览器的css前缀</h2><p>-webkit- : Safari 和 Chrome<br>-moz- : Firefox 4<br>-o- : Opera</p><h2 id="rem与em计算"><a href="#rem与em计算" class="headerlink" title="rem与em计算"></a>rem与em计算</h2><p>em=1/父元素的font-size * 需转换的像素值<br>默认 16px=1em<br>看根元素的px值，根元素的px值=1rem。</p><h2 id="弹性盒子模型flex"><a href="#弹性盒子模型flex" class="headerlink" title="弹性盒子模型flex"></a>弹性盒子模型flex</h2><p>display：flex;</p><ul><li>父元素（6属性）：flex-direction,flex-wrap,flex-flow,justify-content,align-items,align-content</li></ul><ol><li>flex-direction属性决定主轴的方向（即项目的排列方向）。<br><code>flex-direction: row | row-reverse | column | column-reverse;</code></li><li>flex-wrap属性<br>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><code>flex-wrap: nowrap | wrap | wrap-reverse;</code></li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br><code>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</code></li><li>justify-content属性定义了项目在主轴上的对齐方式。<br><code>justify-content: flex-start | flex-end | center | space-between | space-around;</code></li><li>align-items属性定义项目在交叉轴上如何对齐。<br><code>align-items: flex-start | flex-end | center | baseline | stretch;</code></li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</code></li></ol><ul><li>子元素（6属性）：order,flex-grow,flex-shrink,flex-basis,flex,align-self</li></ul><ol><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><code>order: &lt;integer&gt;;</code></li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><code>flex-grow: &lt;number&gt;; /* default 0 */</code></li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><code>flex-shrink: &lt;number&gt;; /* default 1 */</code></li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><code>flex-basis: &lt;length&gt; | auto; /* default auto */</code></li><li>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;</code><br>参考阮一峰博客：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></li></ol><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>bootstrap 的响应式布局原理就是使用了媒体查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-width:600px)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><ol><li>CSS3边框<br>border-radius,box-shadow,border-image</li><li>CSS3背景<br>background-image,background-size,background-origin,background-repeat,background-position,background-clip(背景裁剪属性)<br>background-origin: border-box|content-box;<br>background-clip: border-box|padding-box|content-box;</li><li>CSS3渐变<br>background:linear-gradient(direction,color-stop1,color-stop2…)<br>repeat-linear-gradient:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#grad1 &#123;</span><br><span class="line">  background-image: repeating-linear-gradient(180deg,rgb(26,198,204),rgb(26,198,204) 7%, rgb(100,100,100) 10%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>background: radial-gradient(center,shareSize,start-color,…,end-color);<br>详情见：<a href="http://www.cnblogs.com/lhb25/archive/2013/02/24/css3-radial-gradient.html" target="_blank" rel="noopener">css3-radial-gradient</a></p><ol start="4"><li>CSS3文本效果<br>text-shadow,box-shadow,text-overflow,word-wrap,word-break<br>允许长文本换行：word-wrap: break-word;<br>单词拆分换行：word-break:keep-all;</li><li>2D转换<br>translate():通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。<br>rotate():通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。<br>scale():通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。<br>skew():通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。<br>matrix():<br>matrix()方法把所有 2D 转换方法组合在一起。<br>matrix()方法需要六个参数，包含数学函数，允许旋转、缩放、移动以及倾斜元素。</li><li>3D转换<br>translateY(),translate3D()….<br>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。<br>translate3d(x,y,z) 定义 3D 转化。<br>translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。<br>translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。<br>translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。<br>scale3d(x,y,z) 定义 3D 缩放转换。<br>scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。<br>scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。<br>scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。<br>rotate3d(x,y,z,angle) 定义 3D 旋转。<br>rotateX(angle) 定义沿 X 轴的 3D 旋转。<br>rotateY(angle) 定义沿 Y 轴的 3D 旋转。<br>rotateZ(angle) 定义沿 Z 轴的 3D 旋转。<br>perspective(n) 定义 3D 转换元素的透视视图。</li><li><p>3D过渡<br>transition-property<br>transition-duration<br>transition-timing-function<br>transition-delay<br>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure></li><li><p>CSS3动画<br>@keyframes规则：from to | 百分比时间帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes myfirst&#123;</span><br><span class="line">  from&#123;background: red;&#125;</span><br><span class="line">  to&#123;background: blue;&#125;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;animation:myfirst 5s;&#125;</span><br></pre></td></tr></table></figure></li><li><p>CSS3图片<br>响应式图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">  max-width:100%;</span><br><span class="line">  height:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h2><ol><li>位置属性：(position,top,right,z-index,display,float)</li><li>水平：(width,height,padding,margin)</li><li>文字系列：(font,line-height,letter-spacing)</li><li>背景：(background,border)</li><li>其他：(animation,transition)</li></ol><h2 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h2><p>@font-face<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@font-face&#123;</span><br><span class="line">  font-family:&lt;yourFontName&gt;;</span><br><span class="line">  src: &lt;source&gt;;</span><br><span class="line">  [font-weight:&lt;weight&gt;];</span><br><span class="line">  [font-style:&lt;style&gt;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="浮动与清除浮动"><a href="#浮动与清除浮动" class="headerlink" title="浮动与清除浮动"></a>浮动与清除浮动</h2><p>浮动：浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。<br>浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。显然标准流已经无法满足需求，这就要用到浮动。 浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。<br>造成高度塌陷：父类div不计算浮动元素的高度。<br>(1)父级div手动定义height<br>(2)父级div：overflow:hidden(不使用position)<br>(3)加空标签：clear:both<br>(4)父级使用伪类:after<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:after&#123;</span><br><span class="line">  display:block;</span><br><span class="line">  clear:both;</span><br><span class="line">  content:&quot;&quot;;</span><br><span class="line">  visibility:hidden;</span><br><span class="line">  height:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>//IE兼容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><p>两栏布局，双飞翼布局，圣杯布局，响应式布局，瀑布流布局</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;盒子模型&quot;&gt;&lt;a href=&quot;#盒子模型&quot; class=&quot;headerlink&quot; title=&quot;盒子模型&quot;&gt;&lt;/a&gt;盒子模型&lt;/h2&gt;&lt;p&gt;在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的
      
    
    </summary>
    
      <category term="CSS" scheme="https://qiuyuxiu.github.io/MyBlog/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://qiuyuxiu.github.io/MyBlog/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Node.js创建服务器</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/Node-js%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/Node-js创建服务器/</id>
    <published>2017-06-12T08:51:27.000Z</published>
    <updated>2018-06-07T08:52:12.960Z</updated>
    
    <content type="html"><![CDATA[<p>使用Node.js创建web服务器来相应不同的页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var http=require(&apos;http&apos;);</span><br><span class="line">var fs=require(&apos;fs&apos;);</span><br><span class="line">var url=require(&apos;url&apos;);</span><br><span class="line">//开始web服务器</span><br><span class="line">exports.start=function()&#123;</span><br><span class="line">    var server=http.createServer();</span><br><span class="line">    server.on(&quot;connection&quot;,function()&#123;</span><br><span class="line">        console.log(&quot;一个客户连接！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    server.on(&quot;request&quot;,function(req,res)&#123;</span><br><span class="line">        //res是服务器向客户端的一个输出流</span><br><span class="line">        //req是客户端向服务器的一个输入流</span><br><span class="line">        res.write(&quot;hello world!&quot;);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">    server.listen(3000,function()&#123;</span><br><span class="line">        console.log(&quot;服务器开启成功！&quot;);</span><br><span class="line">    &#125;);//传入端口号</span><br><span class="line">&#125;</span><br><span class="line">exports.start2=function()&#123;</span><br><span class="line">    http.createServer(function(req,res)&#123;</span><br><span class="line">        var path=url.parse(req.url).path;</span><br><span class="line">        var filepath=&quot;&quot;;</span><br><span class="line">        if(path==&quot;/&quot;)&#123;</span><br><span class="line">            filepath=&quot;../index.html&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            filepath=&quot;../&quot;+path;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前请求文件是否存在</span><br><span class="line">        fs.exists(filepath,function(exists)&#123;</span><br><span class="line">            if(exists)&#123;</span><br><span class="line">                var rs=fs.createReadStream(filepath);</span><br><span class="line">                rs.pipe(res);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.statusCode=404;</span><br><span class="line">                var rs=fs.createReadStream(&quot;../404.html&quot;);</span><br><span class="line">                rs.pipe(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).listen(3000,function()&#123;</span><br><span class="line">        console.log(&quot;服务器开启成功！&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Node.js创建web服务器来相应不同的页面。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="NodeJs" scheme="https://qiuyuxiu.github.io/MyBlog/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="https://qiuyuxiu.github.io/MyBlog/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript一些规范</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/JavaScript%E4%B8%80%E4%BA%9B%E8%A7%84%E8%8C%83/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/JavaScript一些规范/</id>
    <published>2017-06-12T08:19:43.000Z</published>
    <updated>2018-06-07T08:44:56.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隐式全局变量和显式全局变量的区别"><a href="#隐式全局变量和显式全局变量的区别" class="headerlink" title="隐式全局变量和显式全局变量的区别"></a>隐式全局变量和显式全局变量的区别</h2><p>隐式的全局变量和显式定义的全局变量之间有着细微的差别，差别在于通过delete来删除它们的时候表现不一致。</p><ul><li>通过var创建的全局变量（在任何函数体之外创建的变量）不能被删除。</li><li>没有用var创建的隐式全局变量（不考虑函数内的情况）可以被删除。<br>也就是说，隐式全局变量并不算是真正的变量，但他们是全局对象的属性成员。属性是可以通过delete运算符删除的，而变量不可以被删除。</li></ul><h2 id="枚举man对象的实例属性"><a href="#枚举man对象的实例属性" class="headerlink" title="枚举man对象的实例属性"></a>枚举man对象的实例属性</h2><p>另外一种的写法是通过Object.prototype 直接调用hasOwnProperty()方法，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i in man) &#123;</span><br><span class="line">if(Object.prototype.hasOwnProperty.call(man,i))&#123;</span><br><span class="line">console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i in man) &#123;</span><br><span class="line">    console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var i,</span><br><span class="line">    hasOwn = Object.prototype.hasOwnProperty;</span><br><span class="line">for (i in man) &#123;</span><br><span class="line">    if (hasOwn.call(man, i)) &#123; // filter</span><br><span class="line">        console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>new Function()的用法和eval()非常类似，应当特别注意。这种构造函数的方式很强大，但往往被误用。<br>如果你不得不使用eval()，你可以尝试用new Function()来代替。这有一个潜在的好处，在new Function()中运行的代码会在一个局部函数作用域内执行，因此源码中所有用var定义的变量不会自动变成全局变量。还有一种方法可以避免eval()中定义的变量转换为全局变量，即是将eval()包装在一个立即执行的匿名函数内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof un);// &quot;undefined&quot;</span><br><span class="line">console.log(typeof deux); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof trois); // &quot;undefined&quot;</span><br><span class="line">var jsstring = &quot;var un = 1; console.log(un);&quot;;</span><br><span class="line">eval(jsstring); // logs &quot;1&quot;</span><br><span class="line">jsstring = &quot;var deux = 2; console.log(deux);&quot;;</span><br><span class="line">new Function(jsstring)(); // logs &quot;2&quot;</span><br><span class="line">jsstring = &quot;var trois = 3; console.log(trois);&quot;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    eval(jsstring);</span><br><span class="line">&#125;()); // logs &quot;3&quot;</span><br><span class="line">console.log(typeof un); // &quot;number&quot;</span><br><span class="line">console.log(typeof deux); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof trois); // &quot;undefined&quot;</span><br></pre></td></tr></table></figure></p><p>eval()和Function构造函数还有一个区别，就是eval()可以修改作用域链，而Function更像是一个沙箱。不管在什么地方执行Function，它只能看到全局作用域。因此它不会太严重的污染局部变量。在下面的示例代码中，eval()可以访问且修改其作用域之外的变量，而Function不能（注意，使用Function和new Function是完全一样的）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var local = 1;</span><br><span class="line">    eval(&quot;local = 3; console.log(local)&quot;); // logs 3</span><br><span class="line">    console.log(local); // logs 3</span><br><span class="line">&#125;());</span><br><span class="line">(function () &#123;</span><br><span class="line">    var local = 1;</span><br><span class="line">    Function(&quot;console.log(typeof local);&quot;)(); // logs undefined</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>适合使用空格的地方包括：</p><ul><li>for循环中的分号之后，比如 <code>for (var i = 0; i &lt; 10; i += 1) {...}</code></li><li>for循环中初始化多个变量，比如 <code>for (var i = 0, max = 10; i &lt; max; i += 1) {...}</code></li><li>分隔数组项的逗号之后，<code>var a = [1, 2, 3];</code></li><li>对象属性后的逗号以及名值对之间的冒号之后，<code>var o = {a: 1, b: 2};</code></li><li>函数参数中，<code>myFunc(a, b, c)</code></li><li>函数声明的花括号之前，<code>function myFunc() {}</code></li><li>匿名函数表达式function之后，<code>var myFunc = function () {};</code></li><li>在运算符和操作数之间添加空格。也就是说在<code>+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=</code>符号前后都添加空格。</li></ul><h2 id="new"><a href="#new" class="headerlink" title="new()"></a>new()</h2><p>当你通过关键字new来调用这个构造函数时，函数体内将发生这些事情：</p><ul><li>创建一个空对象，将它的引用赋给this，继承函数的原型。</li><li>通过this将属性和方法添加至这个对象</li><li>最后返回this指向的新对象（如果没有手动返回其他的对象）</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol><li><p>对象：使用直接量创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var item = new Object();</span><br><span class="line">// good</span><br><span class="line">var item = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>不要使用保留字作为键名</p></li><li>使用同义词替换需要使用的保留字。</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>使用直接量创建数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var items = new Array();</span><br><span class="line">// good</span><br><span class="line">var items = [];</span><br></pre></td></tr></table></figure></li><li><p>向数组增加元素时使用 Array#push 来替代直接赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var someStack = [];</span><br><span class="line">// bad</span><br><span class="line">someStack[someStack.length] = &apos;abracadabra&apos;;</span><br><span class="line">// good</span><br><span class="line">someStack.push(&apos;abracadabra&apos;);</span><br></pre></td></tr></table></figure></li><li><p>当需要拷贝数组时，使用 Array#slice。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var len = items.length;</span><br><span class="line">var itemsCopy = [];</span><br><span class="line">var i;</span><br><span class="line">// bad</span><br><span class="line">for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">itemsCopy = items.slice();</span><br></pre></td></tr></table></figure></li><li><p>使用 Array#slice 将类数组对象转换成数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function trigger()&#123;</span><br><span class="line">  var args=Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li><p>使用单引号 <code>&#39;&#39;</code> 包裹字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var name = &quot;Bob Parr&quot;;</span><br><span class="line">// good</span><br><span class="line">var name = &apos;Bob Parr&apos;;</span><br><span class="line">// bad</span><br><span class="line">var fullName = &quot;Bob &quot; + this.lastName;</span><br><span class="line">// good</span><br><span class="line">var fullName = &apos;Bob &apos; + this.lastName;</span><br></pre></td></tr></table></figure></li><li><p>超过 100 个字符的字符串应该使用连接符写成多行。<br>注：若过度使用，通过连接符连接的长字符串可能会影响性能。</p></li><li>程序化生成的字符串使用 Array#join 连接而不是使用连接符。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var items;</span><br><span class="line">var messages;</span><br><span class="line">var length;</span><br><span class="line">var i;</span><br><span class="line">messages = [&#123;</span><br><span class="line">  state: &apos;success&apos;,</span><br><span class="line">  message: &apos;This one worked.&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  state: &apos;success&apos;,</span><br><span class="line">  message: &apos;This one worked as well.&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  state: &apos;error&apos;,</span><br><span class="line">  message: &apos;This one did not work.&apos;</span><br><span class="line">  &#125;];</span><br><span class="line">length = messages.length;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function inbox(messages) &#123;</span><br><span class="line">  items = &apos;&lt;ul&gt;&apos;;</span><br><span class="line">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">     items += &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return items + &apos;&lt;/ul&gt;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function inbox(messages) &#123;</span><br><span class="line">  items = [];</span><br><span class="line">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">  // use direct assignment in this case because we&apos;re micro-optimizing.</span><br><span class="line">   items[i] = &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &apos;&lt;ul&gt;&apos; + items.join(&apos;&apos;) + &apos;&lt;/ul&gt;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 匿名函数表达式</span><br><span class="line">var anonymous = function() &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line">// 命名函数表达式</span><br><span class="line">var named = function named() &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line">// 立即调用的函数表达式（IIFE）</span><br><span class="line">(function () &#123;</span><br><span class="line">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li><li><p>不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  function test() &#123;</span><br><span class="line">    console.log(&apos;Nope.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">var test;</span><br><span class="line">if (currentUser) &#123;</span><br><span class="line">  test = function test() &#123;</span><br><span class="line">  console.log(&apos;Yup.&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function nope(name, options, arguments) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br><span class="line">// good</span><br><span class="line">function yup(name, options, args) &#123;</span><br><span class="line">  // ...stuff...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li>使用 . 来访问对象的属性。</li><li>当通过变量访问属性时使用中括号 []。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var luke = &#123;</span><br><span class="line">  jedi: true,</span><br><span class="line">  age: 28</span><br><span class="line">&#125;;</span><br><span class="line">function getProp(prop) &#123;</span><br><span class="line">  return luke[prop];</span><br><span class="line">&#125;</span><br><span class="line">var isJedi = getProp(&apos;jedi&apos;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li>总是使用 <code>var</code> 来声明变量。不这么做将导致产生全局变量。我们要避免污染全局命名空间。</li><li>使用 <code>var</code> 声明每一个变量。这样做的好处是增加新变量将变的更加容易，而且永远不用再担心调换错 <code>;</code>跟<code>,</code>。</li><li><p>最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">var items = getItems();</span><br><span class="line">var goSportsTeam = true;</span><br><span class="line">var dragonball;</span><br><span class="line">var length;</span><br><span class="line">var i;</span><br></pre></td></tr></table></figure></li><li><p>在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。</p></li></ol><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>见变量提升篇章</p><h2 id="注释规则"><a href="#注释规则" class="headerlink" title="注释规则"></a>注释规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* make() returns a new element 函数说明</span><br><span class="line">* based on the passed in tag name</span><br><span class="line">*</span><br><span class="line">* @param &#123;String&#125; tag 参数说明</span><br><span class="line">* @return &#123;Element&#125; element 返回值说明</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li><p>在语句开始时执行类型转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//  =&gt; this.reviewScore = 9;</span><br><span class="line">// bad</span><br><span class="line">var totalScore = this.reviewScore + &apos;&apos;;</span><br><span class="line">// good</span><br><span class="line">var totalScore = &apos;&apos; + this.reviewScore;</span><br><span class="line">// bad</span><br><span class="line">var totalScore = &apos;&apos; + this.reviewScore + &apos; total score&apos;;</span><br><span class="line">// good</span><br><span class="line">var totalScore = this.reviewScore + &apos; total score&apos;;</span><br></pre></td></tr></table></figure></li><li><p>使用 parseInt 转换数字时总是带上类型转换的基数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var val = parseInt(inputValue, 10);</span><br></pre></td></tr></table></figure></li></ol><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var age = 0;</span><br><span class="line">// bad</span><br><span class="line">var hasAge = new Boolean(age);</span><br><span class="line">// good</span><br><span class="line">var hasAge = Boolean(age);</span><br><span class="line">// good</span><br><span class="line">var hasAge = !!age;</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">$(this).trigger(&apos;listingUpdated&apos;, listing.id);</span><br><span class="line">...</span><br><span class="line">$(this).on(&apos;listingUpdated&apos;, function (e, listingId) &#123;</span><br><span class="line">// do something with listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>更好的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">$(this).trigger(‘listingUpdated’, &#123; listingId : listing.id &#125;);</span><br><span class="line">…</span><br><span class="line">$(this).on(‘listingUpdated’, function (e, data) &#123;</span><br><span class="line">// do something with data.listingId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="js-随手记"><a href="#js-随手记" class="headerlink" title="js 随手记"></a>js 随手记</h2><ol><li>引用类型的值是对象，保存在堆栈内存中，引用类型的变量是一个指针，保存在栈中，指向堆内存中的对象。</li><li>typeof null 返回的值是object</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;隐式全局变量和显式全局变量的区别&quot;&gt;&lt;a href=&quot;#隐式全局变量和显式全局变量的区别&quot; class=&quot;headerlink&quot; title=&quot;隐式全局变量和显式全局变量的区别&quot;&gt;&lt;/a&gt;隐式全局变量和显式全局变量的区别&lt;/h2&gt;&lt;p&gt;隐式的全局变量和显式定义的全
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://qiuyuxiu.github.io/MyBlog/tags/JavaScript/"/>
    
      <category term="规范" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法记录</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/12/Markdown%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/12/Markdown语法记录/</id>
    <published>2017-06-12T07:05:17.000Z</published>
    <updated>2018-06-07T08:15:43.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>总共六级标题，在#号后加一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></p><h2 id="换行和分段"><a href="#换行和分段" class="headerlink" title="换行和分段"></a>换行和分段</h2><ul><li>换行：只需在行末加两个空格键和一个回车键即可换行。快捷键：control + 回车键</li><li>分段：段落之间空一行即可。</li></ul><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">** 加粗 **</span><br><span class="line">* 斜体 *</span><br><span class="line">~~ 删除线 ~~</span><br><span class="line">` 底纹 `</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表直接在文字前加 -  或者 *  即可，有序列表则直接在文字前加数字 1. 2.。<br>符号要和文字之间加上一个字符的空格。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>只要在文本内容之前加  &gt; （大于号） 即可将文本变成引用文本。</p><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><ul><li>图片<br><code>![图片描述](链接的地址)</code></li><li>链接<br><code>[文本内容](链接的地址)</code></li></ul><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><p>三个 - 或 * 都可以画出一条水平分割线</p><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 两对(```)包裹</span><br><span class="line">- 代码前加四个空格键</span><br><span class="line">- 代码前加一个 tab 键</span><br></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注总是成对出现的，[^1]作为标记，可以点击跳至末尾注解。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注释文字 --&gt;</span><br></pre></td></tr></table></figure></p><h2 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h2><p>在输入法的「全角」模式下，输入两个空格键即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;总共六级标题，在#号后加一个空格。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Markdown语法" scheme="https://qiuyuxiu.github.io/MyBlog/categories/Markdown%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Markdown语法" scheme="https://qiuyuxiu.github.io/MyBlog/tags/Markdown%E8%AF%AD%E6%B3%95/"/>
    
      <category term="前端技术" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo与github博客搭建</title>
    <link href="https://qiuyuxiu.github.io/MyBlog/2017/06/11/hexo%E4%B8%8Egithub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://qiuyuxiu.github.io/MyBlog/2017/06/11/hexo与github博客搭建/</id>
    <published>2017-06-11T11:10:00.000Z</published>
    <updated>2018-06-07T08:16:01.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步-安装Node-js"><a href="#第一步-安装Node-js" class="headerlink" title="第一步 安装Node.js"></a>第一步 安装Node.js</h2><p>在 Windows 环境下安装 Node.js ：到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 安装文件。<br>建议最好下载 nodist，这样方便之后的node版本管理。</p><h2 id="第二步-安装Git"><a href="#第二步-安装Git" class="headerlink" title="第二步 安装Git"></a>第二步 安装Git</h2><p>上官网下载git即可。</p><h2 id="第三步-hexo安装与使用"><a href="#第三步-hexo安装与使用" class="headerlink" title="第三步 hexo安装与使用"></a>第三步 hexo安装与使用</h2><ol><li><p>安装：<br>直接在桌面右键点击git bash here，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure></li><li><p>初始化配置：<br>创建文件夹(如 D:\self\myBlog)，直接进入myBlog文件夹下右键点击git bash here：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>安装hexo插件，(保证之后有些操作不出错, 以下代码可以一起复制粘贴到命令窗):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure></li><li><p>本地查看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li></ol><p>这样就可以在浏览器中访问localhost:4000</p><h2 id="第四步-将博客部署到Github-pages上"><a href="#第四步-将博客部署到Github-pages上" class="headerlink" title="第四步 将博客部署到Github pages上"></a>第四步 将博客部署到Github pages上</h2><ol><li>首先要有github账户。</li><li>创建新的repository，复制到你创建的repository的https链接。</li><li><p>在myBlog文件夹下打开_config.yml<br>在配置文件里修改：(记住：冒号后面一定要有空格！)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 你创建的repository的https链接</span><br><span class="line">  branch: 你的分支</span><br></pre></td></tr></table></figure></li><li><p>在myBlog文件夹下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>我是部署到master分支上，设置master分支为site分支，所以访问创建好的repository链接就能看到效果。<br>注明：如果你不能访问到css，js文件的话，说明路径不对，这时候可以修改_config.yml里面的root值，将root改成你的路径下。</p></li></ol><h2 id="第五步-添加主题美化博客"><a href="#第五步-添加主题美化博客" class="headerlink" title="第五步 添加主题美化博客"></a>第五步 添加主题美化博客</h2><ol><li>进入<a href="https://hexo.io/themes/，选择自己喜欢的主题，复制主题的github的地址。" target="_blank" rel="noopener">https://hexo.io/themes/，选择自己喜欢的主题，复制主题的github的地址。</a></li><li>在myBlog文件夹的themes目录下右键进入git命令框：<br>我选择的是hexo-theme-next 主题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址)</span><br></pre></td></tr></table></figure></li></ol><p>下载完之后。</p><ol start="3"><li>修改myBlog目录下的_config.yml文件里面的theme:hexo-theme-next</li><li><p>部署到github上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>打开自己的主页就能看到效果了。</p></li></ol><h2 id="第六步-配置分类与标签"><a href="#第六步-配置分类与标签" class="headerlink" title="第六步 配置分类与标签"></a>第六步 配置分类与标签</h2><ol><li><p>在myBlog文件夹下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot; // 创建分类</span><br><span class="line">hexo new page &quot;tags&quot; // 创建标签</span><br></pre></td></tr></table></figure></li><li><p>打开/source/categories路径下的index.md,将其修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: catagories</span><br><span class="line">date: 2017-06-11 19:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>打开/source/tags路径下的index.md,将其修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2017-06-11 19:40</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>打开scaffolds/post.md文件，在tags:上面加一行categories:</p></li><li>创建新页面：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;fisrtPage&quot;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到source/_post文件夹下有firstPage.md就能设置categories属性为你想要分类的值，标签设置如果多个标签，设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [tag1,tag2,...]</span><br></pre></td></tr></table></figure></p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><ol><li>设置中文<br>在_config.yml文件中找到language，设置为language: zh-Hans</li><li><p>主页显示分类与标签<br>找到所用主题文件夹（如themes的hexo-theme-next）里的_config.yml<br>找到menu配置处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure></li><li><p>首页不显示文章全文设置：<br>找到所用主题文件夹（如themes的hexo-theme-next）里的_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一步-安装Node-js&quot;&gt;&lt;a href=&quot;#第一步-安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;第一步 安装Node.js&quot;&gt;&lt;/a&gt;第一步 安装Node.js&lt;/h2&gt;&lt;p&gt;在 Windows 环境下安装 Node.js ：到
      
    
    </summary>
    
      <category term="博客创建" scheme="https://qiuyuxiu.github.io/MyBlog/categories/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA/"/>
    
    
      <category term="hexo" scheme="https://qiuyuxiu.github.io/MyBlog/tags/hexo/"/>
    
      <category term="博客" scheme="https://qiuyuxiu.github.io/MyBlog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
